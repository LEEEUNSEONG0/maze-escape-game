<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ÎØ∏Î°ú Î∞©ÌÉàÏ∂ú ÎÇ¥Í∏∞Í≤åÏûÑ!! ¬∑  Version 3.1 (Full View + Team Leaderboard)</title>
<style>
  :root{
    --bgA:#0b1220;
    --bgB:#0a0f1a;
    --card:rgba(255,255,255,.08);
    --border:rgba(255,255,255,.10);
    --text:#e8f0ff;
    --muted:rgba(232,240,255,.70);
    --shadow:0 18px 50px rgba(0,0,0,.55);
    --shadow2:0 10px 26px rgba(0,0,0,.45);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Apple SD Gothic Neo","Noto Sans KR";
    overflow:hidden;
    background:
      radial-gradient(1200px 700px at 20% 15%, rgba(59,130,246,0.28), rgba(59,130,246,0) 60%),
      radial-gradient(1100px 680px at 85% 25%, rgba(168,85,247,0.22), rgba(168,85,247,0) 62%),
      radial-gradient(900px 650px at 55% 85%, rgba(34,197,94,0.18), rgba(34,197,94,0) 60%),
      linear-gradient(180deg,var(--bgA),var(--bgB));
  }

  .app{
    position:fixed; inset:0;
    padding:14px;
    display:grid;
    grid-template-columns: clamp(280px, 26vw, 380px) 1fr;
    grid-template-rows:auto minmax(0, 1fr);
    gap:12px;
  }
  @media (max-width:1100px){
    .app{grid-template-columns:1fr; grid-template-rows:auto auto minmax(0,1fr);}
  }

  .topbar{
    grid-column:1/-1;
    display:flex;align-items:center;justify-content:space-between;
    gap:12px;flex-wrap:wrap;
    padding:12px 14px;
    border-radius:18px;
    border:1px solid var(--border);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    box-shadow:var(--shadow);
    backdrop-filter: blur(12px);
  }
  .title{font-weight:1100;font-size:16px}
  .sub{font-size:12px;color:var(--muted);margin-top:2px}

  .board{
    padding:10px 12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,0.12);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    box-shadow:var(--shadow2);
    min-width:min(640px, 96vw);
  }
  .board .k{font-size:12px;font-weight:1000;color:rgba(255,180,180,0.95)}
  .board .v{font-size:18px;font-weight:1100;margin-top:4px}
  .board .v small{font-size:12px;color:var(--muted);font-weight:900}

  /* --- Top "ÌòÑÏû¨ Íº¥ÏßÄ" board compact --- */
  .lastBoard{
    min-width:220px;
    max-width:360px;
    width:auto;
    padding:8px 10px;
  }
  .lastBoard .k{font-size:11px;font-weight:1000}
  .lastBoard .v{font-size:15px;font-weight:1200;margin-top:2px}
  .lastBoard .v small{font-size:11px}

  /* --- Make difficulty/speed easier to read --- */
  #quickControls #difficulty,
  #quickControls #speed{
    min-width:160px;
  }

  .chips{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}
  .chip{
    min-width:210px;
    padding:10px 12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,0.10);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    box-shadow:var(--shadow2);
  }
  .chip .k{font-size:12px;color:var(--muted);font-weight:1000}
  .chip .v{font-size:18px;font-weight:1100;margin-top:2px}

  /* Quick controls (top bar) */
  .ctrlBlock{
    min-width:280px;
    width:clamp(280px, 34vw, 480px);
    padding:10px 10px;
  }
  .ctrlBlock label{margin-bottom:4px; font-size:11px}

  .ctrlBlock .ctrlGrid{
    display:grid;
    grid-template-columns: 1.35fr 1.35fr 1fr 1fr 0.9fr;
    gap:10px;
    align-items:end;
  }
  .ctrlBlock label{white-space:nowrap}
  .ctrlBlock .bgmUnder{margin-top:6px}
  .ctrlBlock .bgmTopBtn{
    width:100%;
    height:42px;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.10);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    color:var(--text);
    box-shadow:none;
    font-weight:1100;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
  }


  /* Game Screen header controls layout */
  .hd{flex-wrap:wrap}
  .gsHeadLeft{min-width:220px}
  .gsHeadRight{
    display:flex;
    align-items:flex-end;
    gap:12px;
    margin-left:auto;
  }
  .gsControls.ctrlBlock{
    min-width:0;
    width:auto;
    padding:0;
    border:none;
    background:transparent;
    box-shadow:none;
  }
  .gsControls .ctrlGrid{gap:10px}
  .gsControls label{margin-bottom:4px}
  .gsControls .bgmCell{display:flex;flex-direction:column}
  .gsControls .bgmTopBtn{height:42px}

  /* Start button centered text */
  #startBtn{
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
  }
  #startBtn .k, #startBtn .v{width:100%; text-align:center}
  .ctrlBlock .bgmTopBtn.on{
    background:linear-gradient(180deg, rgba(56,189,248,.22), rgba(56,189,248,.10));
    border:1px solid rgba(56,189,248,.35);
    box-shadow:0 12px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(56,189,248,.08) inset;
  }

  .ctrlBlock .bgmTopBtn{
    width:100%;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.10);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    color:var(--text);
    box-shadow:none;
    font-weight:1100;
    cursor:pointer;
  }
  .ctrlBlock .bgmTopBtn.on{
    background:linear-gradient(180deg, rgba(56,189,248,.22), rgba(56,189,248,.10));
    border:1px solid rgba(56,189,248,.35);
    box-shadow:0 12px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(56,189,248,.08) inset;
  }

  @media (max-width: 980px){
    .ctrlBlock{width:100%}
    .ctrlBlock .ctrlGrid{grid-template-columns: repeat(3, minmax(0,1fr));}
  }
  @media (max-width: 520px){
    .ctrlBlock .ctrlGrid{grid-template-columns:1fr}
  }


  
  .tensionChip{min-width:320px}
  .tensionChip .k{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
    color:rgba(255,150,150,0.98);
  }
  .tensionChip .trow{
    margin-top:8px;
    display:flex;align-items:center;justify-content:space-between;gap:12px;
  }
  .tensionChip .bar{
    flex:1;
    height:12px;border-radius:999px;
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(255,255,255,0.06);
    overflow:hidden;
  }
  .tensionChip .fill{
    height:100%;
    width:0%;
    background:linear-gradient(90deg, rgba(34,197,94,0.85), rgba(245,158,11,0.92), rgba(239,68,68,0.95));
    border-radius:999px;
    transition:width .12s ease;
  }
  .tensionChip .txt{
    font-weight:1400;
    color:rgba(255,220,220,0.92);
    white-space:nowrap;
  }
  
  .panicHUD{display:none !important;}
  
  
  .startTopBtn{
    min-width:210px;
    padding:10px 14px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,0.18);
    background:linear-gradient(180deg, rgba(59,130,246,0.98), rgba(14,165,233,0.90));
    color:#eaf2ff;
    box-shadow:0 18px 36px rgba(59,130,246,0.18), 0 10px 26px rgba(0,0,0,.35);
    cursor:pointer;
    text-align:left;
    position:relative;
    overflow:hidden;
    user-select:none;
  }
  .startTopBtn .k{font-size:12px;font-weight:1100;opacity:.86;letter-spacing:-0.2px}
  .startTopBtn .v{font-size:18px;font-weight:1500;margin-top:2px;letter-spacing:-0.5px;text-shadow:0 10px 26px rgba(0,0,0,.12)}
  .startTopBtn:hover{transform:translateY(-1px)}
  .startTopBtn:active{transform:translateY(0)}
  .startTopBtn:disabled{opacity:.55;cursor:not-allowed;filter:saturate(.75)}
  .startTopBtn::before{
    content:'';
    position:absolute;
    inset:-50% -70%;
    background:linear-gradient(90deg, transparent, rgba(255,255,255,.35), transparent);
    transform:translateX(-60%) rotate(18deg);
    animation:shine 3.2s ease-in-out infinite;
    pointer-events:none;
  }
  .startTopBtn:disabled::before{display:none}
  @keyframes shine{
    0%{transform:translateX(-70%) rotate(18deg)}
    60%{transform:translateX(70%) rotate(18deg)}
    100%{transform:translateX(70%) rotate(18deg)}
  }

.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;color:rgba(232,240,255,.70)}

  .card{
    border:1px solid rgba(255,255,255,0.10);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    border-radius:18px;
    box-shadow:var(--shadow);
    overflow:hidden;
    display:flex;
    flex-direction:column;
    min-height:0;
  }
  .hd{
    padding:16px 16px 10px;
    border-bottom:1px solid rgba(255,255,255,0.08);
    display:flex;justify-content:space-between;align-items:center;gap:10px;
  }
  .hd .t{font-weight:1100;font-size:16px}
  .hd .s{font-size:12px;color:var(--muted);margin-top:2px}

  .bd{
    padding:14px 16px 16px;
    flex:1;
    min-height:0;
  }

  label{display:block;font-size:12px;color:var(--muted);font-weight:1000;margin-bottom:6px}
  input,select{
    width:100%;
    padding:10px 12px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(10,14,24,0.62);
    color:var(--text);
    outline:none;
    font-weight:900;
  }
  input::placeholder{color:rgba(232,240,255,.55)}
  .row{display:grid;grid-template-columns:1fr 120px;gap:10px;align-items:end}
  .row2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}

  .btn{
    width:100%;
    border:none;
    border-radius:12px;
    padding:10px 12px;
    font-weight:1100;
    cursor:pointer;
    background:linear-gradient(180deg, rgba(34,197,94,0.95), rgba(16,185,129,0.92));
    color:#052016;
    box-shadow:0 10px 22px rgba(34,197,94,0.16);
  }
  .btn.secondary{
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    color:var(--text);
    box-shadow:none;
    border:1px solid rgba(255,255,255,0.10);
  }
  .btn.secondary.on{
    background:linear-gradient(180deg, rgba(56,189,248,.22), rgba(56,189,248,.10));
    border:1px solid rgba(56,189,248,.35);
    box-shadow:0 12px 30px rgba(0,0,0,.35), 0 0 0 1px rgba(56,189,248,.08) inset;
  }

  .btn.small{padding:8px 10px;border-radius:10px;font-size:12px;width:auto}

  
  .list{
    margin-top:12px;
    display:flex;
    flex-direction:column;
    gap:8px;
    max-height:34vh;
    overflow:auto;
    padding-right:2px
  }
  .item{
    display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;
    padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,0.10);
    background:rgba(10,14,24,0.40);
  }
  .nm{font-weight:1100;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:flex;gap:8px;align-items:center}
  .badge{
    width:12px;height:12px;border-radius:999px;
    box-shadow:0 0 0 2px rgba(255,255,255,.12);
    flex:0 0 auto;
  }
  .controls{display:flex;gap:8px;align-items:center}
  .countBox{
    width:84px;text-align:center;
    padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,0.14);
    background:rgba(10,14,24,0.62);color:var(--text);font-weight:1100;
  }
  .nameBox{
    width:150px;
    padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,0.14);
    background:rgba(10,14,24,0.62);color:var(--text);font-weight:1100;
  }

  
  #setupCard .bd{
    display:flex;
    flex-direction:column;
    gap:0;
    min-height:0;
  }
  #setupCard .list{
    flex:1;
    min-height:0;
    max-height:none;     
    overflow:auto;
    margin-bottom:12px;  
  }
  #startBtn{
    position:relative;
    bottom:auto;
    z-index:5;
    margin-top:0;
    box-shadow:0 18px 36px rgba(59,130,246,0.16), 0 10px 26px rgba(0,0,0,.35);
  }
  /* start button is now in setup header (under Reset) */
  .hdBtns{display:flex;flex-direction:column;gap:8px;align-items:stretch;min-width:210px}
  .startInSetup{min-width:210px; width:210px}
  .fullInSetup{width:100%; min-width:0; text-align:left}
  @media (max-width:1100px){
    .hdBtns{min-width:0}
    .startInSetup{width:100%}
  }

  .stageSplit{
    display:grid;
    grid-template-columns:minmax(0,1fr) minmax(260px, 26vw);
    gap:12px;
    height:100%;
    min-height:0;
  }
  @media (max-width:1100px){ .stageSplit{grid-template-columns:1fr} }

  .canvasWrap{position:relative; height:100%; min-height:0;}
  canvas{
    width:100%;
    height:100%;
    border-radius:18px;
    border:1px solid rgba(255,255,255,0.12);
    background:
      radial-gradient(1200px 800px at 45% 40%, rgba(34,197,94,0.22), rgba(34,197,94,0) 60%),
      radial-gradient(1100px 760px at 65% 35%, rgba(59,130,246,0.24), rgba(59,130,246,0) 60%),
      radial-gradient(900px 650px at 50% 90%, rgba(168,85,247,0.20), rgba(168,85,247,0) 62%),
      linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.03));
  }

  .rankPanel{
    border:1px solid rgba(255,255,255,0.12);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
    border-radius:18px;
    padding:12px;
    box-shadow:var(--shadow2);
    height:100%;
    min-height:0;
    overflow:auto;
  }
  .rankPanel .h{
    font-weight:1200;font-size:14px;
    display:flex;justify-content:space-between;gap:10px;
    position:sticky;top:0;z-index:2;
    background:rgba(10,14,24,0.72);
    padding:10px 10px;border-radius:14px;border:1px solid rgba(255,255,255,0.10);
    backdrop-filter: blur(8px);
  }

  .rankBig{
    margin-top:10px;
    display:flex;flex-direction:column;gap:10px;
  }
  .rankCard{
    border:1px solid rgba(255,255,255,0.10);
    background:rgba(10,14,24,0.42);
    border-radius:16px;
    padding:12px 12px;
  }
  .rankCard.out{opacity:.55}
  .rankTop{
    display:flex;align-items:center;justify-content:space-between;gap:12px;
  }
  .rankLeft{
    display:flex;align-items:center;gap:10px;min-width:0;
  }
  .rankNum{
    font-weight:1500;
    font-size:18px;
    letter-spacing:-0.4px;
    width:34px;
    height:34px;
    display:grid;
    place-items:center;
    border-radius:12px;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.12);
    text-align:center;
  }
  .rankName{
    font-weight:1400;
    font-size:20px;
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }
  .rankMeta{
    margin-top:6px;
    display:flex;gap:10px;flex-wrap:wrap;
    color:rgba(232,240,255,.80);
    font-weight:1100;
    font-size:13px;
  }
  .pillMini{
    display:inline-flex;align-items:center;gap:8px;
    padding:7px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,0.12);
    background:rgba(10,14,24,0.55);
  }
  .dot{
    width:10px;height:10px;border-radius:999px;
    box-shadow:0 0 0 2px rgba(255,255,255,.12);
  }

  .overlay{
    position:absolute;
    top:50%; left:50%;
    transform:translate(-50%,-50%) scale(.98);
    display:flex; align-items:center; justify-content:center;
    pointer-events:none;
    padding:10px 14px;
    border-radius:16px;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.10);
    backdrop-filter: blur(10px);
    font-weight:900;
    font-size:44px;
    letter-spacing:.5px;
    text-shadow:0 10px 28px rgba(0,0,0,0.75);
    opacity:0;
    transition:opacity .15s ease, transform .15s ease;
    z-index:5;
  }
  .overlay.show{opacity:1;transform:translate(-50%,-50%) scale(1)}

  .escapeBanner{
    position:absolute;right:14px;top:14px;
    transform:none;
    pointer-events:none;
    padding:12px 14px;border-radius:16px;
    border:2px solid rgba(34,197,94,0.35);
    background:rgba(10,14,24,0.82);
    box-shadow:0 24px 70px rgba(0,0,0,0.55);
    opacity:0;transition:opacity .18s ease, transform .18s ease;
    text-align:left;
    min-width:min(420px,84vw);
    backdrop-filter: blur(10px);
  }
  .escapeBanner.show{opacity:1;transform:scale(1.01)}
  .escapeBanner .k{
    font-size:11px;font-weight:1200;
    color:rgba(110,255,170,0.95);
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .escapeBanner .k span{opacity:.85}
  .escapeBanner .v{
    font-size:28px;font-weight:1500;letter-spacing:-0.8px;margin-top:6px;color:#d7ffe9
  }
  .escapeBanner .s{
    font-size:12px;font-weight:1100;margin-top:6px;color:rgba(232,240,255,0.78)
  }

  .tensionFrame{
    position:absolute;inset:10px;border-radius:18px;pointer-events:none;
    opacity:0;transition:opacity .25s ease;
    box-shadow: inset 0 0 0 3px rgba(255,90,90,0.35), 0 0 0 9999px rgba(255,60,60,0.06);
  }
  .tensionFrame.show{opacity:1}

    .penalty{
    position:absolute;inset:0;
    display:flex;align-items:center;justify-content:center;
    pointer-events:none;
    opacity:0;transform:scale(0.98);
    transition:opacity .22s ease, transform .22s ease;
  }
  
  .penalty.show{opacity:1;transform:scale(1)}
  .penalty.show::before{
    content:'';
    position:absolute;inset:0;
    border-radius:18px;
    background:
      radial-gradient(900px 520px at 50% 52%, rgba(255,80,80,0.18), rgba(255,80,80,0) 60%),
      radial-gradient(1200px 900px at 50% 55%, rgba(0,0,0,0.55), rgba(0,0,0,0.72) 62%);
    box-shadow: inset 0 0 240px rgba(0,0,0,0.75);
    opacity:0.0;
    animation:lastDim .95s ease-in-out infinite;
  }
  @keyframes lastDim{
    0%{opacity:.70}
    50%{opacity:.95}
    100%{opacity:.70}
  }

  .penalty .board{
    padding:18px 20px;border-radius:22px;
    border:3px solid rgba(255,90,90,0.70);
    background:rgba(10,14,24,0.86);
    box-shadow:0 30px 80px rgba(0,0,0,0.65);
    text-align:center;
    min-width:min(820px,92vw);
    backdrop-filter: blur(12px);
    position:relative;
    overflow:hidden;
  }

  
  .penalty.show .board{
    animation:lastPop .55s cubic-bezier(.2,1.2,.2,1) both, lastPulse 1.05s ease-in-out infinite .55s, lastShake 0.18s ease-in-out infinite .55s;
  }
  @keyframes lastPop{
    0%{ transform:translateY(10px) scale(0.90); filter:blur(1px); }
    60%{ transform:translateY(-4px) scale(1.03); filter:blur(0px); }
    100%{ transform:translateY(0px) scale(1.00); }
  }
  @keyframes lastPulse{
    0%{ box-shadow:0 30px 80px rgba(0,0,0,0.65), 0 0 0 0 rgba(255,80,80,0.00); }
    45%{ box-shadow:0 30px 80px rgba(0,0,0,0.65), 0 0 0 18px rgba(255,80,80,0.10); }
    100%{ box-shadow:0 30px 80px rgba(0,0,0,0.65), 0 0 0 0 rgba(255,80,80,0.00); }
  }
  @keyframes lastShake{
    0%{ transform:translateY(0) }
    25%{ transform:translateY(-1px) }
    50%{ transform:translateY(0) }
    75%{ transform:translateY(1px) }
    100%{ transform:translateY(0) }
  }

  
  .penalty .board::before{
    content:'';
    position:absolute;inset:-40% -60%;
    background:linear-gradient(90deg, transparent, rgba(255,140,140,0.22), transparent);
    transform:translateX(-70%) rotate(14deg);
    animation:lastSweep 1.55s ease-in-out infinite;
    pointer-events:none;
  }
  @keyframes lastSweep{
    0%{transform:translateX(-75%) rotate(14deg); opacity:.0}
    15%{opacity:1}
    65%{opacity:1}
    100%{transform:translateX(75%) rotate(14deg); opacity:0}
  }

  .penalty .h{font-size:18px;font-weight:1300;color:rgba(255,140,140,0.98)}
  .penalty .n{
    margin-top:10px;
    font-size:72px;
    font-weight:1600;
    color:#ffb3b3;
    letter-spacing:-1.2px;
    text-shadow:0 18px 44px rgba(0,0,0,0.65), 0 0 22px rgba(255,120,120,0.25);
  }
  .penalty .s{margin-top:10px;font-size:14px;font-weight:1100;color:rgba(232,240,255,0.80)}

  .panicHUD{
    position:absolute;left:14px;top:14px;
    pointer-events:none;
    padding:10px 12px;border-radius:16px;
    border:2px solid rgba(255,90,90,0.35);
    background:rgba(10,14,24,0.78);
    box-shadow:0 22px 60px rgba(0,0,0,0.52);
    min-width:min(420px,84vw);
    opacity:0;transform:translateY(-4px);
    transition:opacity .18s ease, transform .18s ease;
    backdrop-filter: blur(10px);
  }
  .panicHUD.show{opacity:1;transform:translateY(0)}
  .panicHUD .k{
    font-size:11px;font-weight:1300;
    color:rgba(255,150,150,0.98);
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .panicHUD .v{
    margin-top:8px;
    display:flex;align-items:center;justify-content:space-between;gap:12px;
  }
  .panicHUD .bar{
    flex:1;
    height:12px;border-radius:999px;
    border:1px solid rgba(255,255,255,0.14);
    background:rgba(255,255,255,0.06);
    overflow:hidden;
  }
  .panicHUD .fill{
    height:100%;
    width:0%;
    background:linear-gradient(90deg, rgba(34,197,94,0.85), rgba(245,158,11,0.92), rgba(239,68,68,0.95));
    border-radius:999px;
    transition:width .12s ease;
  }
  .panicHUD .txt{
    font-weight:1400;
    color:rgba(255,220,220,0.92);
    white-space:nowrap;
  }

  .panicVignette{
    position:absolute;inset:0;
    pointer-events:none;
    opacity:0;
    transition:opacity .18s ease;
    border-radius:18px;
    box-shadow: inset 0 0 0 9999px rgba(0,0,0,0.00);
  }
  .panicVignette.show{
    opacity:1;
    box-shadow:
      inset 0 0 0 9999px rgba(0,0,0,0.00),
      inset 0 0 220px rgba(0,0,0,0.65),
      inset 0 0 0 3px rgba(255,90,90,0.18);
  }

  .panicPulse{
    position:absolute;inset:0;
    pointer-events:none;
    opacity:0;
    transition:opacity .12s ease;
    border-radius:18px;
    background:radial-gradient(900px 520px at 50% 55%, rgba(255,80,80,0.08), rgba(255,80,80,0) 60%);
    mix-blend-mode:screen;
  }
  .panicPulse.show{
    opacity:1;
    animation: panicPulse 0.95s ease-in-out infinite;
  }
  @keyframes panicPulse{
    0%{ transform:scale(0.995); filter:blur(0px); opacity:0.55; }
    50%{ transform:scale(1.005); filter:blur(0.2px); opacity:0.95; }
    100%{ transform:scale(0.995); filter:blur(0px); opacity:0.55; }
  }

  .panicStamp{
    position:absolute;left:50%;top:52%;
    transform:translate(-50%,-50%) scale(0.98);
    pointer-events:none;
    opacity:0;
    transition:opacity .14s ease, transform .14s ease;
    text-align:center;
    padding:10px 14px;border-radius:18px;
    border:2px solid rgba(255,90,90,0.30);
    background:rgba(10,14,24,0.62);
    box-shadow:0 24px 70px rgba(0,0,0,0.55);
    backdrop-filter: blur(10px);
  }
  .panicStamp.show{
    opacity:1;
    transform:translate(-50%,-50%) scale(1.00);
  }
  .panicStamp .big{
    font-size:34px;
    font-weight:1600;
    letter-spacing:-1.0px;
    color:rgba(255,190,190,0.95);
    text-shadow:0 16px 40px rgba(0,0,0,0.70);
  }
  .panicStamp .small{
    margin-top:6px;
    font-size:12px;
    font-weight:1200;
    color:rgba(232,240,255,0.80);
  }


.devPopup{
  position:fixed; inset:0;
  background:radial-gradient(800px 500px at 50% 40%, rgba(255,0,150,.35), rgba(0,0,0,0) 60%), rgba(0,0,0,.75);
  display:none; align-items:center; justify-content:center;
  z-index:9999;
  padding:18px;
}
.devPopup.show{display:flex}

.devCard{
  max-width:520px; width:100%;
  background:linear-gradient(180deg, #1a002b, #2b0057);
  border-radius:24px;
  padding:20px;
  color:#ffffff;
  box-shadow:
    0 40px 120px rgba(0,0,0,.85),
    0 0 0 2px rgba(255,0,180,.45),
    0 0 40px rgba(255,0,180,.35);
  position:relative;
  overflow:hidden;
  animation:devPop .35s ease;
}
@keyframes devPop{
  from{transform:scale(.9);opacity:0}
  to{transform:scale(1);opacity:1}
}
.devHero{
  display:flex; gap:14px; align-items:center;
  padding:16px;
  border-radius:18px;
  background:linear-gradient(135deg, #ff008c, #ff6a00);
  box-shadow:0 12px 40px rgba(255,80,0,.45);
}
.devIcon{
  width:52px; height:52px;
  display:grid; place-items:center;
  border-radius:16px;
  background:#ffffff;
  color:#ff008c;
  font-size:26px;
  font-weight:1600;
  box-shadow:0 10px 26px rgba(0,0,0,.35);
}
.devHero h2{
  margin:0;
  font-size:24px;
  font-weight:1600;
}
.devLead{
  margin:6px 0 0;
  font-size:14px;
  font-weight:1200;
  line-height:1.5;
}
.devCta{
  margin-top:14px;
  padding:16px;
  border-radius:18px;
  background:#12001f;
}
.devCtaLabel{
  font-size:12px;
  opacity:.85;
  margin-bottom:8px;
}
.walletBox{
  display:flex; gap:10px; align-items:center; flex-wrap:wrap;
}
.walletBox code{
  flex:1 1 300px;
  padding:12px;
  background:#000;
  border-radius:14px;
  font-size:13px;
  word-break:break-all;
  border:1px solid rgba(255,0,180,.6);
  box-shadow:0 0 18px rgba(255,0,180,.45) inset;
  user-select:all;
}
.copyBtn{
  padding:12px 18px;
  border:none;
  border-radius:14px;
  cursor:pointer;
  font-weight:1600;
  background:linear-gradient(180deg, #00f0ff, #00bcd4);
  color:#002b2e;
  box-shadow:0 12px 30px rgba(0,240,255,.55);
}
.copyBtn:active{transform:translateY(1px)}
.devFooter{
  margin-top:14px;
  display:flex; justify-content:space-between; align-items:center;
  gap:10px; flex-wrap:wrap;
}
.devBy{font-size:12px; opacity:.9}
.closeBtn{
  padding:10px 16px;
  border-radius:999px;
  border:none;
  background:#ff008c;
  color:#fff;
  font-weight:1400;
  cursor:pointer;
  box-shadow:0 10px 26px rgba(255,0,140,.45);
}
.devToast{
  position:absolute;
  bottom:16px; left:50%;
  transform:translateX(-50%);
  padding:10px 16px;
  border-radius:999px;
  background:#00f0ff;
  color:#002b2e;
  font-weight:1400;
  opacity:0;
  transition:opacity .15s ease;
}
.devToast.show{opacity:1}


.pcOnlyBadge{
  display:inline-flex;
  align-items:center;
  gap:6px;
  margin-top:6px;
  padding:4px 10px;
  border-radius:999px;
  font-size:11px;
  font-weight:1200;
  letter-spacing:-0.2px;
  color:#ffecec;
  background:linear-gradient(180deg, rgba(239,68,68,.95), rgba(185,28,28,.95));
  box-shadow:0 6px 18px rgba(239,68,68,.45);
}


/* =========================
   Mobile optimization layer
   ========================= */
@supports (height: 100dvh){
  html,body{height:100dvh}
}
@media (max-width: 820px){
  body{
    overflow:auto;                 /* allow page scroll on small screens */
    -webkit-text-size-adjust:100%;
    overscroll-behavior:contain;
  }

  .app{
    position:relative;             /* avoid fixed layout issues on mobile */
    inset:auto;
    padding:12px;
    padding-left:calc(12px + env(safe-area-inset-left));
    padding-right:calc(12px + env(safe-area-inset-right));
    padding-top:calc(12px + env(safe-area-inset-top));
    padding-bottom:calc(12px + env(safe-area-inset-bottom));
    grid-template-columns: 1fr;
    grid-template-rows: auto auto auto;
  }

  .topbar{
    flex-direction:column;
    align-items:stretch;
    gap:10px;
  }

  /* prevent "min-width" from forcing horizontal scroll */
  .board{min-width:0;width:100%}

  .chips{
    justify-content:flex-start;
    gap:10px;
  }

  .chip, .startTopBtn{
    min-width:0;
    width:100%;
  }

  .startTopBtn{
    text-align:center;
  }

  /* Stack game screen + ranking vertically */
  .stageSplit{
    grid-template-columns:1fr;
  }

  /* Give canvas a stable mobile height */
  .canvasWrap{
    height:52vh;
    min-height:360px;
  }

  /* Ranking panel below canvas with reasonable height */
  .rankPanel{
    height:auto;
    max-height:42vh;
  }

  /* Reduce some big typography to fit */
  .overlay{font-size:34px}
  .escapeBanner{min-width:0; width:calc(100% - 28px); right:14px}
  .penalty .board{min-width:0}
  .penalty .n{font-size:52px}

  /* Inputs / buttons slightly larger for touch */
  input,select{padding:12px 12px; font-size:16px}
  .btn{padding:12px 12px}
  .btn.small{padding:10px 10px}

  /* The players list should not become too tall */
  .list{max-height:28vh}



/* Ensure Game Screen controls are fully visible on mobile */
.gsHeadRight{
  width:100%;
  margin-left:0;
}
.gsControls{
  width:100%;
}
.gsControls .ctrlGrid{
  grid-template-columns: repeat(2, minmax(0,1fr));
  gap:10px;
}
/* Put BGM and START on their own full-width rows for visibility */
.gsControls .bgmCell{
  grid-column: 1 / -1;
}
.gsControls .startCell{
  grid-column: 1 / -1;
}



/* Prevent min-width controls from forcing clipping */
#quickControls #difficulty,
#quickControls #speed{
  min-width:0 !important;
}
#quickControls select{
  min-width:0 !important;
  width:100%;
}
/* Make Random Jump / Portal always visible (own rows on very narrow screens) */
@media (max-width: 520px){
  .gsControls .ctrlGrid{
    grid-template-columns: 1fr;
  }
}
}

/* Very small screens */
@media (max-width: 420px){
  .title{font-size:15px}
  .sub{font-size:11px}
  .chip .v{font-size:16px}
  .rankName{font-size:18px}
}



/* ===== Game Screen START button (moved next to difficulty) ===== */
.gsControls .ctrlGrid.ctrlGridWithStart{
  grid-template-columns: 1.35fr 1.35fr 1fr 1fr 0.9fr 1.1fr;
}
.startCell{display:flex;flex-direction:column}
.startGameBtn{
  width:100%;
  height:42px;
  border-radius:14px;
  border:2px solid rgba(255,80,80,.85);
  background:linear-gradient(180deg, rgba(255,59,59,0.98), rgba(185,28,28,0.92));
  color:#fff;
  font-weight:1600;
  letter-spacing:.6px;
  cursor:pointer;
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  box-shadow:0 0 0 1px rgba(255,255,255,.15) inset, 0 14px 32px rgba(255,0,0,.38);
  position:relative;
  overflow:hidden;
  user-select:none;
  transition:transform .12s ease, filter .12s ease;
}
.startGameBtn:hover{transform:translateY(-1px) scale(1.02); filter:saturate(1.05)}
.startGameBtn:active{transform:translateY(0) scale(1.0)}
.startGameBtn:disabled{opacity:.55;cursor:not-allowed;filter:saturate(.75)}
.startGameBtn::before{
  content:'';
  position:absolute;
  inset:-60% -70%;
  background:linear-gradient(90deg, transparent, rgba(255,255,255,.55), transparent);
  transform:translateX(-80%) rotate(18deg);
  animation:startShine 2.8s ease-in-out infinite;
  pointer-events:none;
}
.startGameBtn:disabled::before{display:none}
@keyframes startShine{
  0%{transform:translateX(-80%) rotate(18deg)}
  60%{transform:translateX(80%) rotate(18deg)}
  100%{transform:translateX(80%) rotate(18deg)}
}
.startGameBtn .startIcon{
  font-size:16px;
  filter:drop-shadow(0 0 6px rgba(255,255,255,.7));
}
.startGameBtn .startText{font-size:14px; line-height:1}

</style>
</head>

<body>
<div class="app">
  <div class="topbar">
    <div style="display:flex;gap:10px;align-items:flex-start">
      <div style="font-size:22px">üéÆ</div>
      <div>
        <div class="title">ÎØ∏Î°ú Î∞©ÌÉàÏ∂ú ÎÇ¥Í∏∞Í≤åÏûÑ!! ¬∑  Version 3.1</div>
        <div class="sub">Í∞úÎ∞úÏûê Î¨∏Ïùò : wwwing6240@gmail.com</div>
      </div>
    </div>

    <div class="board lastBoard">
      <div class="k">üî¥ ÌòÑÏû¨ Íº¥ÏßÄ</div>
      <div class="v" id="lastText">- <small>Add players and press start</small></div>
    </div>

    <div class="chips">
      
      <div class="chip"><div class="k">ÌÉàÏ∂ú</div><div class="v"><span id="escaped">0</span> / <span id="total">0</span></div></div>
      <div class="chip"><div class="k">ÏãúÍ∞Ñ</div><div class="v"><span id="time">0.0s</span> ¬∑ <span id="state">Ready</span></div></div>
      <div class="chip tensionChip" id="tensionChip">
        <div class="k"><span>‚ö†Ô∏è TENSION</span><span class="mono" id="panicMiniTop">-</span></div>
        <div class="v trow">
          <div class="bar"><div class="fill" id="panicFillTop"></div></div>
          <div class="txt" id="panicTextTop">-</div>
        </div>
      </div>
    </div>
  </div>

  
  <section class="card" id="setupCard">
    <div class="hd">
      <div>
        <div class="t">‚öôÔ∏è Ï∞∏Í∞ÄÏûê ÏÑ§Ï†ï</div>
        <div class="s">Ï≤òÏùå Í∏∞Î≥∏ 4Î™Ö(ÏòÅÏàò/ÏòÅÌò∏/ÏàúÏûê/Ï†ïÌù¨) ¬∑ Î™©Î°ùÏóêÏÑú Ïù¥Î¶Ñ Î≥ÄÍ≤Ω Í∞ÄÎä•</div>
      </div>
      <div class="hdBtns">
        <button class="btn secondary" id="resetBtn">Reset</button>
</div>
    </div>
    <div class="bd">
<div class="row">
        <div>
          <label>Ïù¥Î¶Ñ(ÌåÄ)</label>
          <input id="nameInput" placeholder="ÏòÅÏ≤†">
        </div>
        <div>
          <label>Ïù∏ÏõêÏàò</label>
          <input id="countInput" type="number" min="1" max="200" value="1">
        </div>
      </div>
      <div style="height:10px"></div>
      <button class="btn" id="addBtn">Ï∂îÍ∞Ä</button>

      <div style="height:12px"></div>

      
      <div class="row2">
</div>

<div class="list" id="roster"></div>
      <div class="mono" style="font-size:12px;opacity:.78">‚Äª <b style="color:#fff">Í≤åÏûÑ ÏãúÏûë</b> Î≤ÑÌäºÏùÄ <b style="color:#fff">Í≤åÏûÑ ÌôîÎ©¥ ÏÉÅÎã®(ÎÇúÏù¥ÎèÑ ÏòÜ)</b>Ïóê ÏûàÏäµÎãàÎã§.</div>
</div>
  </section>

  <section class="card">
    <div class="hd">
      <div class="gsHeadLeft"><div class="t">üé• Game Screen</div></div><div class="gsHeadRight"><div class="gsControls ctrlBlock" id="quickControls">
        <div class="ctrlGrid ctrlGridWithStart">
          <div>
            <label>ÎÇúÏù¥ÎèÑ</label>
            <select id="difficulty">
            <option value="1">Level 1 (Very Easy)</option>
            <option value="2">Level 2 (Easy)</option>
            <option value="3" selected>Level 3 (Normal)</option>
            <option value="4">Level 4 (Hard)</option>
            <option value="5">Level 5 (Hell)</option>
            <option value="6">Level 6 (Inferno)</option>
            <option value="7">Level 7 (Extreme)</option>
          </select>
          </div>
          <div>
            <label>ÏÜçÎèÑ</label>
            <select id="speed">
            <option value="1">Level 1 (Slow)</option>
            <option value="2">2</option>
            <option value="3" selected>Level 3 (Default)</option>
            <option value="4">4</option>
            <option value="5">Level 5 (Very Fast)</option>
          </select>
          </div>
          <div class="bungeeCell">
            <label>ÎûúÎç§Ï†êÌîÑ</label>
            <select id="bungeeCount"></select>
</div>
          <div>
            <label>ÌÉàÏ∂úÌè¨ÌÉà</label>
            <select id="portalCount"></select>
          </div>
        
          
<div class="bgmCell">
            <label>BGM</label>
            <button class="bgmTopBtn" id="bgmBtn">üîá BGM OFF</button>
          </div>
<div class="startCell">
  <label>&nbsp;</label>
  <button id="startBtn" class="startGameBtn" type="button">
    <span class="startIcon">‚ñ∂</span>
    <span class="startText">GAME START</span>
  </button>
</div>
</div>
      </div>
        <span class="mono" id="pill">Idle</span></div></div>
    <div class="bd">
      <div class="stageSplit">
        <div class="canvasWrap">
          <canvas id="cv"></canvas>
          <div class="overlay" id="overlay">3</div>

          <div class="panicHUD" id="panicHUD">
            <div class="k">
              <span>‚ö†Ô∏è TENSION</span>
              <span class="mono" id="panicMini">-</span>
            </div>
            <div class="v">
              <div class="bar"><div class="fill" id="panicFill"></div></div>
              <div class="txt" id="panicText">-</div>
            </div>
          </div>
          <div class="panicVignette" id="panicVignette"></div>
          <div class="panicPulse" id="panicPulse"></div>
          <div class="panicStamp" id="panicStamp">
            <div class="big" id="panicStampBig">FINAL -</div>
            <div class="small" id="panicStampSmall">-</div>
          </div>

          <div class="escapeBanner" id="escapeBanner">
            <div class="k">
              <span>üìπ CCTV ¬∑ ESCAPE</span>
              <span class="mono" id="escapeMiniTime">-</span>
            </div>
            <div class="v" id="escapeName">-</div>
            <div class="s" id="escapeSub">-</div>
          </div>

          <div class="tensionFrame" id="tensionFrame"></div>

          <div class="penalty" id="penalty">
            <div class="board">
              <div class="h">üéØ Î≤åÏπô ÎãπÏ≤® (ÏµúÌõÑ 1Ïù∏)</div>
              <div class="n" id="penaltyName">-</div>
              <div class="s" id="penaltyTime">-</div>
            </div>
          </div>
        </div>

        <aside class="rankPanel">
          <div class="h">
            <div>üèÅ Ïã§ÏãúÍ∞Ñ ÏàúÏúÑ (ÌåÄ/Ï∞∏Í∞ÄÏûê Í∏∞Ï§Ä)</div>
            <div class="mono" id="lrCount">0 players</div>
          </div>
            <div class="rankBig" id="lrList"></div>
        </aside>
      </div>
    </div>
  </section>
</div>

<script>
(() => {
  'use strict';

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>a+Math.random()*(b-a);
  const TAU=Math.PI*2;
  const wait=(ms)=>new Promise(r=>setTimeout(r,ms));
  const easeInOut=t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;
  const key=(x,y)=>x+'|'+y;

  
  const cv=document.getElementById('cv');
  const ctx=cv.getContext('2d');

  const overlay=document.getElementById('overlay');
  const nameInput=document.getElementById('nameInput');
  const countInput=document.getElementById('countInput');
  const addBtn=document.getElementById('addBtn');
  const startBtn=document.getElementById('startBtn');
  const resetBtn=document.getElementById('resetBtn');
  const diffSel=document.getElementById('difficulty');
  const speedSel=document.getElementById('speed');
  const bungeeSel=document.getElementById('bungeeCount');
  const portalSel=document.getElementById('portalCount');
  const bgmBtn=document.getElementById('bgmBtn');
  const rosterEl=document.getElementById('roster');

  const escapedEl=document.getElementById('escaped');
  const totalEl=document.getElementById('total');
  const remainEl=document.getElementById('remain');
  const timeEl=document.getElementById('time');
  const stateEl=document.getElementById('state');
  const phaseEl=document.getElementById('phase'); 
  const tensionChip=document.getElementById('tensionChip');
  const panicMiniTop=document.getElementById('panicMiniTop');
  const panicFillTop=document.getElementById('panicFillTop');
  const panicTextTop=document.getElementById('panicTextTop');
  const pill=document.getElementById('pill');
  const lrCountEl=document.getElementById('lrCount');
  const lrListEl=document.getElementById('lrList');
  const lastText=document.getElementById('lastText');
  const spTiles=document.getElementById('spTiles'); 

  const escapeBanner=document.getElementById('escapeBanner');
  const escapeNameEl=document.getElementById('escapeName');
  const escapeSubEl=document.getElementById('escapeSub');
  const escapeMiniTime=document.getElementById('escapeMiniTime');
  const tensionFrame=document.getElementById('tensionFrame');
  const penaltyEl=document.getElementById('penalty');
  const penaltyNameEl=document.getElementById('penaltyName');
  const penaltyTimeEl=document.getElementById('penaltyTime');

  const panicHUD=document.getElementById('panicHUD');
  const panicMini=document.getElementById('panicMini');
  const panicFill=document.getElementById('panicFill');
  const panicText=document.getElementById('panicText');
  const panicVignette=document.getElementById('panicVignette');
  const panicPulse=document.getElementById('panicPulse');
  const panicStamp=document.getElementById('panicStamp');
  const panicStampBig=document.getElementById('panicStampBig');
  const panicStampSmall=document.getElementById('panicStampSmall');

  
  function fill(sel, def){
    sel.innerHTML='';
    
    for(let i=0;i<=10;i++){
      const o=document.createElement('option');
      o.value=String(i);
      o.textContent = (i===0 ? '0' : String(i));
      sel.appendChild(o);
    }
    sel.value=String(def);
  }
  fill(bungeeSel, 0);
  fill(portalSel, 0);

  
  let audio=null;
  let wantBGM=false;

  function ensureAudio(){
    if(audio) return audio;
    const AC=window.AudioContext||window.webkitAudioContext;
    const ac=new AC();
    const master=ac.createGain();
    master.gain.value=0.18;
    master.connect(ac.destination);

    let enabled=false;
    let timer=null;
    let next=0;
    let bpm=160;
    const div=4;
    const step=()=> (60/bpm)/div;

    const root=220;
    const hz=(semi)=>root*Math.pow(2,semi/12);
    const bassSeq=[0,0,0,-3, -5,-5,-5,-7, 0,0,-3,-3, -5,-5,-7,-10];
    const leadSeq=[12,15,19,15, 12,15,19,22, 12,15,19,15, 24,22,19,15];

    function tone(at,f,d,type,vol){
      const o=ac.createOscillator();
      const g=ac.createGain();
      o.type=type;
      o.frequency.setValueAtTime(Math.max(20,f), at);
      g.gain.setValueAtTime(0.0001, at);
      g.gain.exponentialRampToValueAtTime(vol, at+0.008);
      g.gain.exponentialRampToValueAtTime(0.0001, at+d);
      o.connect(g).connect(master);
      o.start(at); o.stop(at+d+0.05);
    }
    function noise(at,d,vol){
      const len=Math.max(0.02,d);
      const buf=ac.createBuffer(1, Math.floor(ac.sampleRate*len), ac.sampleRate);
      const data=buf.getChannelData(0);
      for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*Math.pow(1-i/data.length,2);
      const src=ac.createBufferSource(); src.buffer=buf;
      const g=ac.createGain();
      g.gain.setValueAtTime(0.0001, at);
      g.gain.exponentialRampToValueAtTime(vol, at+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, at+len);
      const hp=ac.createBiquadFilter(); hp.type='highpass'; hp.frequency.setValueAtTime(800, at);
      src.connect(hp).connect(g).connect(master);
      src.start(at); src.stop(at+len+0.02);
    }
    function kick(at,vol=0.55){
      const o=ac.createOscillator();
      const g=ac.createGain();
      o.type='sine';
      o.frequency.setValueAtTime(160, at);
      o.frequency.exponentialRampToValueAtTime(48, at+0.10);
      g.gain.setValueAtTime(0.0001, at);
      g.gain.exponentialRampToValueAtTime(vol, at+0.008);
      g.gain.exponentialRampToValueAtTime(0.0001, at+0.22);
      o.connect(g).connect(master);
      o.start(at); o.stop(at+0.25);
    }
    function hat(at){ noise(at,0.03,0.10); }
    function clap(at){ noise(at,0.06,0.22); tone(at, hz(19), 0.06, 'square', 0.06); }

    function tick(){
      const now=ac.currentTime;
      while(next < now + 0.25){
        const sd=step();
        const i=Math.floor(next/sd);

        if(i%8===0) kick(next, 0.60);
        if(i%2===1) hat(next);
        if(i%16===8) clap(next);

        if(i%4===0){
          const b=bassSeq[(i/4)%bassSeq.length];
          tone(next, hz(b-12), sd*3.8, 'triangle', 0.20);
          tone(next, hz(b-24), sd*3.8, 'sine', 0.12);
        }
        if(i%2===0){
          const n=leadSeq[(i/2)%leadSeq.length];
          tone(next, hz(n), sd*0.90, 'sawtooth', 0.08);
          tone(next, hz(n+12), sd*0.45, 'square', 0.03);
        }

        next += sd;
      }
      timer=setTimeout(tick, 55);
    }
    function start(){ enabled=true; next=ac.currentTime+0.05; tick(); }
    function stop(){ enabled=false; if(timer) clearTimeout(timer); timer=null; }
    function setTempo(mult){ bpm=clamp(160*mult, 92, 204); }
    function setVol(v){ master.gain.value=clamp(v,0,0.30); }

    function boom(at, base=90, vol=0.55){
      kick(at, vol);
      tone(at, base, 0.10, 'sine', vol*0.18);
      noise(at, 0.08, vol*0.20);
      tone(at+0.02, base*2, 0.06, 'square', vol*0.08);
    }
    function fanfare(){
      const now=ac.currentTime;
      const seq=[
        {t:0.00, s:19, d:0.10},
        {t:0.10, s:24, d:0.10},
        {t:0.20, s:27, d:0.10},
        {t:0.30, s:31, d:0.14},
        {t:0.46, s:36, d:0.18},
      ];
      boom(now, 150, 0.52);
      for(const n of seq){
        tone(now+n.t, hz(n.s), n.d, 'sawtooth', 0.12);
        tone(now+n.t, hz(n.s-12), n.d*0.95, 'square', 0.05);
      }
      noise(now+0.10,0.07,0.18);
      noise(now+0.32,0.08,0.20);
    }

    function sfxCountdown(n){
      const now=ac.currentTime;
      const f=n===3?620:n===2?740:n===1?880:1040;
      tone(now, f, 0.10, 'square', 0.22);
      if(n==='GO'){ boom(now, 120, 0.60); }
    }
    function sfxBungee(){ const now=ac.currentTime; boom(now,110,0.78); tone(now, hz(24), 0.12, 'sawtooth', 0.18); }
    function sfxPortal(){ const now=ac.currentTime; boom(now,130,0.78); tone(now, hz(48), 0.10, 'sawtooth', 0.16); noise(now,0.10,0.20); }
    function sfxEscape(){ fanfare(); }
    function sfxLastTwo(){ const now=ac.currentTime; tone(now, 110, 0.35, 'triangle', 0.22); tone(now+0.06,110,0.35,'triangle',0.22); }

    function sfxPanicBeep(strength=1.0){
      const now=ac.currentTime;
      const v=0.05*clamp(strength,0.6,1.4);
      tone(now, 820, 0.06, 'square', v);
      tone(now+0.08, 620, 0.06, 'square', v*0.85);
      noise(now+0.02, 0.05, v*0.65);
    }

    audio={ac,start,stop,setTempo,setVol,sfxCountdown,sfxBungee,sfxPortal,sfxEscape,sfxLastTwo,sfxPanicBeep,
      get enabled(){return enabled;}
    };
    return audio;
  }

  function updateBgmButton(){
    
    bgmBtn.textContent = wantBGM ? 'üîä BGM ON' : 'üîá BGM OFF';
    bgmBtn.classList.toggle('on', wantBGM);
  }

  function setBGM(on){
    const a=ensureAudio();
    if(a.ac.state==='suspended') a.ac.resume();
    if(on){
      if(!a.enabled) a.start();
    }else{
      if(a.enabled) a.stop();
    }
  }

  function applyBGM(){
    
    try{
      if(wantBGM && (state==='playing' || state==='countdown')) setBGM(true);
      else setBGM(false);
    }catch(e){}
  }


  bgmBtn.addEventListener('click', ()=>{
    wantBGM = !wantBGM;
    updateBgmButton();
    applyBGM();
  });

  updateBgmButton();
updateBgmButton();

  
  let roster=new Map();
  let teamStyle=new Map();
  const clampCount=n=>clamp(parseInt(n||'1',10)||1,1,200);

  const TEAM_COLORS=[
    {c:'#60a5fa', a:'#93c5fd'},
    {c:'#f59e0b', a:'#fbbf24'},
    {c:'#22c55e', a:'#86efac'},
    {c:'#a855f7', a:'#c4b5fd'},
    {c:'#ef4444', a:'#fca5a5'},
    {c:'#06b6d4', a:'#67e8f9'},
    {c:'#e11d48', a:'#fda4af'},
    {c:'#84cc16', a:'#bef264'},
    {c:'#f97316', a:'#fdba74'},
    {c:'#14b8a6', a:'#5eead4'},
    {c:'#8b5cf6', a:'#ddd6fe'},
    {c:'#3b82f6', a:'#bfdbfe'}
  ];

  const AVATARS=[
    {type:'ninja',  hair:'mask',  prop:'katana'},
    {type:'robot',  hair:'anten', prop:'jet'},
    {type:'pirate', hair:'hat',   prop:'hook'},
    {type:'mage',   hair:'hood',  prop:'orb'},
    {type:'runner', hair:'cap',   prop:'bolt'},
    {type:'bear',   hair:'ears',  prop:'paw'},
    {type:'alien',  hair:'horn',  prop:'ray'},
    {type:'knight', hair:'helm',  prop:'shield'}
  ];

  function esc(s){
    return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;')
      .replaceAll('"','&quot;').replaceAll("'","&#039;");
  }

  function nextFreeColor(){
    const used = new Set([...teamStyle.values()].map(v=>v.color));
    for(const col of TEAM_COLORS){
      if(!used.has(col.c)) return col;
    }
    return TEAM_COLORS[used.size % TEAM_COLORS.length];
  }

  function ensureTeamStyle(name){
    if(teamStyle.has(name)) return teamStyle.get(name);
    const col=nextFreeColor();
    const av=AVATARS[Math.floor(Math.random()*AVATARS.length)];
    const style={color:col.c, accent:col.a, avatar:av};
    teamStyle.set(name, style);
    return style;
  }

  
  const N=1,E=2,S=4,W=8;
  const DX={ [N]:0,[E]:1,[S]:0,[W]:-1 };
  const DY={ [N]:-1,[E]:0,[S]:1,[W]:0 };
  const OPP={ [N]:S,[E]:W,[S]:N,[W]:E };

  let gridW=23, gridH=23, cells=[], startCell={x:0,y:0}, exits=[], distToExit=[];

  function diffLevel(){ return clamp(parseInt(diffSel.value||'3',10)||3,1,7); }
  function speedLevel(){ return clamp(parseInt(speedSel.value||'3',10)||3,1,5); }
  function idx(x,y){ return y*gridW+x; }

  function openDirs(x,y){
    const m=cells[idx(x,y)];
    const res=[];
    if((m & N)===0) res.push(N);
    if((m & E)===0) res.push(E);
    if((m & S)===0) res.push(S);
    if((m & W)===0) res.push(W);
    return res;
  }
  function knockWall(x1,y1,x2,y2){
    const dx=x2-x1, dy=y2-y1;
    let dir=null;
    if(dx===0 && dy===-1) dir=N;
    else if(dx===1 && dy===0) dir=E;
    else if(dx===0 && dy===1) dir=S;
    else if(dx===-1 && dy===0) dir=W;
    if(!dir) return false;
    const before=cells[idx(x1,y1)] & dir;
    if(before===0) return false;
    cells[idx(x1,y1)] &= ~dir;
    cells[idx(x2,y2)] &= ~OPP[dir];
    return true;
  }
  function carveStartPlaza(r){
    const cx=startCell.x, cy=startCell.y;
    for(let y=cy-r;y<=cy+r;y++){
      for(let x=cx-r;x<=cx+r;x++){
        if(x<0||y<0||x>=gridW||y>=gridH) continue;
        if(x+1<=cx+r && x+1<gridW) knockWall(x,y,x+1,y);
        if(y+1<=cy+r && y+1<gridH) knockWall(x,y,x,y+1);
      }
    }
  }
  function buildDist(){
    distToExit=new Array(gridW*gridH).fill(Infinity);
    const q=[];
    for(const ex of exits){
      distToExit[idx(ex.x,ex.y)]=0;
      q.push({x:ex.x,y:ex.y});
    }
    let qi=0;
    while(qi<q.length){
      const c=q[qi++];
      const d0=distToExit[idx(c.x,c.y)];
      for(const dir of openDirs(c.x,c.y)){
        const nx=c.x+DX[dir], ny=c.y+DY[dir];
        if(nx<0||ny<0||nx>=gridW||ny>=gridH) continue;
        const ii=idx(nx,ny);
        if(distToExit[ii] > d0+1){
          distToExit[ii]=d0+1;
          q.push({x:nx,y:ny});
        }
      }
    }
  }

  function sizeByDiff(lv){
    if(lv===1) return {w:19,h:19};
    if(lv===2) return {w:21,h:21};
    if(lv===3) return {w:23,h:23};
    if(lv===4) return {w:27,h:27};
    if(lv===5) return {w:29,h:29};
    if(lv===6) return {w:33,h:33};
    return {w:35,h:35};
  }

  function initMaze(){
    const lv=diffLevel();
    const sz=sizeByDiff(lv);
    gridW=sz.w; gridH=sz.h;

    cells=new Array(gridW*gridH).fill(N|E|S|W);
    startCell={x:Math.floor(gridW/2), y:Math.floor(gridH/2)};

    const vis=new Array(gridW*gridH).fill(false);
    const stack=[{x:startCell.x,y:startCell.y}];
    vis[idx(startCell.x,startCell.y)]=true;

    while(stack.length){
      const c=stack[stack.length-1];
      const dirs=[N,E,S,W].filter(dir=>{
        const nx=c.x+DX[dir], ny=c.y+DY[dir];
        if(nx<0||ny<0||nx>=gridW||ny>=gridH) return false;
        return !vis[idx(nx,ny)];
      });
      if(!dirs.length){ stack.pop(); continue; }
      const dir=dirs[(Math.random()*dirs.length)|0];
      const nx=c.x+DX[dir], ny=c.y+DY[dir];
      cells[idx(c.x,c.y)] &= ~dir;
      cells[idx(nx,ny)] &= ~OPP[dir];
      vis[idx(nx,ny)]=true;
      stack.push({x:nx,y:ny});
    }

    const extra = (lv===1)?18 : (lv===2)?32 : (lv===3)?52 : (lv===4)?72 : 88;
    for(let i=0;i<extra;i++){
      const x=1+((Math.random()*(gridW-2))|0);
      const y=1+((Math.random()*(gridH-2))|0);
      const dir=[N,E,S,W][(Math.random()*4)|0];
      const nx=x+DX[dir], ny=y+DY[dir];
      if(nx<0||ny<0||nx>=gridW||ny>=gridH) continue;
      knockWall(x,y,nx,ny);
    }

    const cx=Math.floor(gridW/2), cy=Math.floor(gridH/2);
    exits=[
      {x:cx,y:0,label:'North (N)', i:0},
      {x:gridW-1,y:cy,label:'East (E)', i:1},
      {x:cx,y:gridH-1,label:'South (S)', i:2},
      {x:0,y:cy,label:'West (W)', i:3},
    ];

    for(const ex of exits){
      if(ex.y===0){ cells[idx(ex.x,0)] &= ~S; cells[idx(ex.x,1)] &= ~N; }
      else if(ex.y===gridH-1){ cells[idx(ex.x,gridH-1)] &= ~N; cells[idx(ex.x,gridH-2)] &= ~S; }
      else if(ex.x===0){ cells[idx(0,ex.y)] &= ~E; cells[idx(1,ex.y)] &= ~W; }
      else if(ex.x===gridW-1){ cells[idx(gridW-1,ex.y)] &= ~W; cells[idx(gridW-2,ex.y)] &= ~E; }
    }

    carveStartPlaza(4);
    buildDist();
  }

  let relaxPhase=0;
  function relaxMazeStep(){
    const lv=diffLevel();
    const base = (lv===1)?20 : (lv===2)?18 : (lv===3)?16 : (lv===4)?14 : (lv===5)?12 : (lv===6)?10 : 8;
    const openCount = base + relaxPhase*6;
    let opened=0;
    for(let t=0;t<14000 && opened<openCount;t++){
      const x=1+((Math.random()*(gridW-2))|0);
      const y=1+((Math.random()*(gridH-2))|0);
      const md=Math.abs(x-startCell.x)+Math.abs(y-startCell.y);
      if(md<4) continue;
      const dir=[N,E,S,W][(Math.random()*4)|0];
      const nx=x+DX[dir], ny=y+DY[dir];
      if(nx<1||ny<1||nx>=gridW-1||ny>=gridH-1) continue;
      if(knockWall(x,y,nx,ny)) opened++;
    }
    buildDist();
  }

  
  let Wpx=900, Hpx=600, dpr=1;
  let cellSize=24, offX=0, offY=0;

  const camera={x:0,y:0,zoom:1, tx:0,ty:0,tz:1, shake:0};
  let baseZoom=1;

  function cellToWorld(x,y){
    return { x: offX + x*cellSize + cellSize/2, y: offY + y*cellSize + cellSize/2 };
  }
  function worldRect(){ return {x:offX,y:offY,w:cellSize*gridW,h:cellSize*gridH}; }
  function setCameraTarget(x,y){ camera.tx=x; camera.ty=y; camera.tz=baseZoom; }
  function cameraKick(a=0.6){ camera.shake=Math.min(1.0, camera.shake+a); }
  function cameraUpdate(dt){
    const k=Math.max(0, Math.min(1, 6*dt));
    camera.x=lerp(camera.x,camera.tx,k);
    camera.y=lerp(camera.y,camera.ty,k);
    camera.zoom=lerp(camera.zoom,camera.tz,k);
    if(camera.shake>0) camera.shake=Math.max(0,camera.shake-dt*1.8);
  }
  function fitCanvas(){
    dpr=Math.max(1, Math.min(2, window.devicePixelRatio||1));
    cv.width=Math.round(cv.clientWidth*dpr);
    cv.height=Math.round(cv.clientHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    Wpx=cv.clientWidth; Hpx=cv.clientHeight;

    const pad=28;
    cellSize=Math.floor(Math.min((Wpx-pad*2)/gridW,(Hpx-pad*2)/gridH));
    cellSize=Math.max(12,cellSize);
    offX=Math.floor((Wpx-cellSize*gridW)/2);
    offY=Math.floor((Hpx-cellSize*gridH)/2);

    const wr=worldRect();
    baseZoom=Math.min(Wpx/wr.w, Hpx/wr.h)*0.98;

    const s=cellToWorld(startCell.x,startCell.y);
    camera.x=s.x; camera.y=s.y;
    camera.tx=s.x; camera.ty=s.y;
    camera.zoom=baseZoom;
    camera.tz=baseZoom;

    ctx.imageSmoothingEnabled = false;
  }
  window.addEventListener('resize', ()=>{ fitCanvas(); draw(); });

  
  let bungees=[], portals=[];
  let bungeeSet=new Set(), portalSet=new Set();
  const isBungee=(x,y)=>bungeeSet.has(key(x,y));
  const isPortal=(x,y)=>portalSet.has(key(x,y));

  function minDistFromStart(){
    const lv=diffLevel();
    return (lv>=7)?12 : (lv>=6)?11 : (lv>=5)?10 : (lv<=2)?8 : 9;
  }

  function randomCellAvoidStart(minDist){
    for(let tries=0;tries<50000;tries++){
      const x=1+((Math.random()*(gridW-2))|0);
      const y=1+((Math.random()*(gridH-2))|0);
      const md=Math.abs(x-startCell.x)+Math.abs(y-startCell.y);
      if(md<minDist) continue;
      return {x,y};
    }
    return {x:clamp(startCell.x+minDist,1,gridW-2), y:startCell.y};
  }
  function portalExitNearCell(){
    const ex=exits[(Math.random()*exits.length)|0];
    const r=2+((Math.random()*2)|0);
    let x=ex.x, y=ex.y;
    if(ex.y===0) y=clamp(ex.y+r,1,gridH-2);
    else if(ex.y===gridH-1) y=clamp(ex.y-r,1,gridH-2);
    else if(ex.x===0) x=clamp(ex.x+r,1,gridW-2);
    else if(ex.x===gridW-1) x=clamp(ex.x-r,1,gridW-2);
    x=clamp(x+(((Math.random()*3)|0)-1),1,gridW-2);
    y=clamp(y+(((Math.random()*3)|0)-1),1,gridW-2);
    return {x,y};
  }
  
  
  function dirOfCell(x,y){
    const top = y <= Math.floor(gridH*0.25);
    const bottom = y >= Math.floor(gridH*0.75);
    const left = x <= Math.floor(gridW*0.25);
    const right = x >= Math.floor(gridW*0.75);
    
    if(top && !left && !right) return 'N';
    if(bottom && !left && !right) return 'S';
    if(left && !top && !bottom) return 'W';
    if(right && !top && !bottom) return 'E';
    
    const dN = y;
    const dS = (gridH-1)-y;
    const dW = x;
    const dE = (gridW-1)-x;
    const m = Math.min(dN,dS,dW,dE);
    if(m===dN) return 'N';
    if(m===dS) return 'S';
    if(m===dW) return 'W';
    return 'E';
  }
  function countsByDir(arr){
    const c={N:0,E:0,S:0,W:0};
    for(const t of arr){ c[dirOfCell(t.x,t.y)]++; }
    return c;
  }
  function pickLeastDir(arr){
    const c=countsByDir(arr);
    const dirs=['N','E','S','W'];
    let best=dirs[0], bestV=c[best];
    for(const d of dirs){
      const v=c[d];
      if(v<bestV){ bestV=v; best=d; }
    }
    
    const mins=dirs.filter(d=>c[d]===bestV);
    return mins[(Math.random()*mins.length)|0];
  }
  function randomCellInDir(dir, minDist){
    
    let x=1,y=1;
    if(dir==='N'){
      y = 1 + ((Math.random()*Math.max(1,Math.floor(gridH*0.25)-1))|0);
      x = 1 + ((Math.random()*(gridW-2))|0);
    }else if(dir==='S'){
      const y0 = Math.max(1,Math.floor(gridH*0.75));
      y = y0 + ((Math.random()*Math.max(1,(gridH-2)-y0+1))|0);
      x = 1 + ((Math.random()*(gridW-2))|0);
    }else if(dir==='W'){
      x = 1 + ((Math.random()*Math.max(1,Math.floor(gridW*0.25)-1))|0);
      y = 1 + ((Math.random()*(gridH-2))|0);
    }else{ 
      const x0 = Math.max(1,Math.floor(gridW*0.75));
      x = x0 + ((Math.random()*Math.max(1,(gridW-2)-x0+1))|0);
      y = 1 + ((Math.random()*(gridH-2))|0);
    }
    
    const md=Math.abs(x-startCell.x)+Math.abs(y-startCell.y);
    if(md<minDist) return randomCellAvoidStart(minDist);
    return {x,y};
  }

function updateSpTiles(){ if(!spTiles) return; spTiles.textContent=`B${bungees.length} / P${portals.length}`; }

  function addOneBungee(){
    const minDist=minDistFromStart();
    const prefer = pickLeastDir(bungees);
    
    for(let tries=0;tries<2500;tries++){
      const c=randomCellInDir(prefer, minDist);
      const k=key(c.x,c.y);
      if(bungeeSet.has(k) || portalSet.has(k)) continue;
      bungees.push({x:c.x,y:c.y,pulse:rand(0,TAU)});
      bungeeSet.add(k); return true;
    }
    
    for(let tries=0;tries<2500;tries++){
      const c=randomCellAvoidStart(minDist);
      const k=key(c.x,c.y);
      if(bungeeSet.has(k) || portalSet.has(k)) continue;
      bungees.push({x:c.x,y:c.y,pulse:rand(0,TAU)});
      bungeeSet.add(k); return true;
    }
    return false;
  }
  function addOnePortal(){
    const minDist=minDistFromStart();
    const prefer = pickLeastDir(portals);
    for(let tries=0;tries<2500;tries++){
      const c=randomCellInDir(prefer, minDist);
      const k=key(c.x,c.y);
      if(portalSet.has(k) || bungeeSet.has(k)) continue;
      portals.push({x:c.x,y:c.y,rot:rand(0,TAU)});
      portalSet.add(k); return true;
    }
    for(let tries=0;tries<2500;tries++){
      const c=randomCellAvoidStart(minDist);
      const k=key(c.x,c.y);
      if(portalSet.has(k) || bungeeSet.has(k)) continue;
      portals.push({x:c.x,y:c.y,rot:rand(0,TAU)});
      portalSet.add(k); return true;
    }
    return false;
  }
  function removeOneBungee(){
    if(!bungees.length) return false;
    const t=bungees.pop();
    bungeeSet.delete(key(t.x,t.y));
    return true;
  }
  function removeOnePortal(){
    if(!portals.length) return false;
    const t=portals.pop();
    portalSet.delete(key(t.x,t.y));
    return true;
  }
  function syncSpecialTilesToUI(){
    const targetB=clamp(parseInt(bungeeSel.value||'0',10)||0,0,10);
    const targetP=clamp(parseInt(portalSel.value||'0',10)||0,0,10);

while(bungees.length < targetB){ if(!addOneBungee()) break; }
    while(bungees.length > targetB){ if(!removeOneBungee()) break; }
    while(portals.length < targetP){ if(!addOnePortal()) break; }
    while(portals.length > targetP){ if(!removeOnePortal()) break; }

    updateSpTiles();
    draw();
  }
  function buildSpecialTilesFresh(){
    bungees=[]; portals=[];
    bungeeSet=new Set(); portalSet=new Set();
    syncSpecialTilesToUI();
  }
  bungeeSel.addEventListener('change', syncSpecialTilesToUI);
  portalSel.addEventListener('change', syncSpecialTilesToUI);

  
  let particles=[];
  function spawnBurst(x,y,col,n=16,sp=260){
    for(let i=0;i<n;i++){
      const ang=rand(0,TAU), v=rand(sp*0.35,sp);
      particles.push({x,y,vx:Math.cos(ang)*v,vy:Math.sin(ang)*v,r:rand(2,6),a:0.98,col, g:220});
    }
  }
  function spawnFireworks(x,y){
    const palette=['rgba(34,197,94,0.98)','rgba(59,130,246,0.98)','rgba(168,85,247,0.98)','rgba(245,158,11,0.98)','rgba(239,68,68,0.98)'];
    for(let k=0;k<3;k++){
      spawnBurst(x+rand(-20,20),y+rand(-20,20),palette[(Math.random()*palette.length)|0],34,360);
    }
  }

  
  const SKILLS=[
    {tag:'‚ö°', kind:'dash'},
    {tag:'üî•', kind:'turbo'},
    {tag:'üí´', kind:'after'},
    {tag:'üß≤', kind:'magnet'},
    {tag:'üé≤', kind:'luck'},
  ];
  const uid=()=>Math.random().toString(16).slice(2)+Math.random().toString(16).slice(2);

  let agents=[], crowd=[];
  function rebuildCrowd(){
    crowd=new Array(gridW*gridH).fill(0);
    for(const a of agents){
      if(a.escaped || a.teleport) continue;
      crowd[idx(a.cx,a.cy)]++;
    }
  }
  function agentPickNext(a){
    const dirs=openDirs(a.cx,a.cy);
    if(!dirs.length){ a.tx=a.cx; a.ty=a.cy; return; }
    const hereD=distToExit[idx(a.cx,a.cy)];
    const phaseBias=0.10 + relaxPhase*0.18;
    const d=diffLevel();
    
    const skill = (8 - d) / 7; 

    let best=null, bestScore=-1e9;
    for(const dir of dirs){
      const nx=a.cx+DX[dir], ny=a.cy+DY[dir];
      const nd=distToExit[idx(nx,ny)];
      const improvement=(hereD-nd);
      const visits=a.mem.get(key(nx,ny))||0;
      const cpen=crowd[idx(nx,ny)]||0;

      let distScore = improvement*phaseBias*skill;
      distScore += isPortal(nx,ny) ? (0.45*skill) : 0;
      
      distScore += rand(-0.22,0.30) * (1 + (d-1)*0.18);

      const score = rand(0,1.0) + (visits===0?0.58:0) - visits*0.14 - cpen*0.22 + distScore;
      if(score>bestScore){ bestScore=score; best={nx,ny}; }
    }
    a.tx=best.nx; a.ty=best.ny;
  }

  function buildAgents(){
    agents=[];
    const all=[];
    for(const [name,count] of roster.entries()){
      for(let i=0;i<count;i++) all.push({name});
    }
    const s=cellToWorld(startCell.x,startCell.y);
    const ringR=Math.max(16, cellSize*0.72);

    for(let i=0;i<all.length;i++){
      const it=all[i];
      const style=ensureTeamStyle(it.name);
      const skill=SKILLS[(Math.random()*SKILLS.length)|0];

      const ang=(i/Math.max(1,all.length))*TAU;
      const ox=Math.cos(ang)*ringR + rand(-14,14);
      const oy=Math.sin(ang)*ringR + rand(-14,14);

      agents.push({
        id:uid(),
        name:it.name,
        team:it.name,
        style,
        skill,
        cx:startCell.x, cy:startCell.y,
        tx:startCell.x, ty:startCell.y,
        x:s.x+ox, y:s.y+oy, vx:0, vy:0,
        escaped:false,
        escapeRank:0,
        escapeTime:0,
        mem:new Map(),
        teleport:null,
        cd:0,
        after:[],
        stepT:Math.random()*TAU,
        speedNow:0,
      });
    }

    rebuildCrowd();
    for(const a of agents) agentPickNext(a);
  }

  
  function doTeleportArc(a, dst, arcMul=1.0, kind='jump'){
    const p0={x:a.x,y:a.y};
    const p1=cellToWorld(dst.x,dst.y);
    a.teleport={t:0,dur:0.52+Math.random()*0.22,x0:p0.x,y0:p0.y,x1:p1.x,y1:p1.y,arc:cellSize*(4.4+Math.random()*3.2)*arcMul,kind};
    a.vx=a.vy=0;
    a.cx=dst.x; a.cy=dst.y;
    a.tx=dst.x; a.ty=dst.y;
    cameraKick(kind==='portal'?0.75:0.85);
  }
  function tryBungee(a){
    if(a.escaped||a.teleport) return false;
    if(!isBungee(a.cx,a.cy)) return false;
    const dst=randomCellAvoidStart(minDistFromStart());
    doTeleportArc(a,dst,1.25,'jump');
    spawnBurst(a.x,a.y,'rgba(255,80,120,0.98)',28,380);
    spawnBurst(a.x,a.y,'rgba(255,200,80,0.92)',18,320);
    ensureAudio().sfxBungee();
    return true;
  }
  function tryPortal(a){
    if(a.escaped||a.teleport) return false;
    if(!isPortal(a.cx,a.cy)) return false;
    const dst=portalExitNearCell();
    doTeleportArc(a,dst,0.95,'portal');
    spawnBurst(a.x,a.y,'rgba(180,120,255,0.98)',30,360);
    spawnBurst(a.x,a.y,'rgba(80,180,255,0.92)',16,300);
    ensureAudio().sfxPortal();
    return true;
  }

  
  let state='ready';
  let elapsed=0, t0=0, raf=0;
  let escapeCounter=0;
  let lastTwoTriggered=false;

  
  const finalFlashShown = {2:false,3:false};
  let finalFlashUntil = 0;


  function setOverlay(text, show){
    overlay.textContent=text;
    overlay.classList.toggle('show', !!show);
  }

  function updateHUD(){
    const total=agents.length;
    const escCount=agents.filter(a=>a.escaped).length;
    escapedEl.textContent=String(escCount);
    totalEl.textContent=String(total);
    if(remainEl) remainEl.textContent=(total-escCount)>0?`${total-escCount}`:'-';
    timeEl.textContent=(Math.round(elapsed*10)/10).toFixed(1)+'s';
    stateEl.textContent=(state==='playing')?'Playing':(state==='countdown')?'':(state==='finished')?'Finished':'Ready';
        if(phaseEl) phaseEl.textContent=String(relaxPhase);
  }

  
  
  
  
  
  let groupRankMem = new Map(); 
  let groupOrderSeed = 0;
  let groupChangeSeq = 0;

function updateRank(){
    const preGame = (agents.length===0 || state==='ready');

    
    let entries=[];
    if(preGame){
      for(const [name,count] of roster.entries()){
        for(let i=0;i<count;i++){
          entries.push({name, team:name, pre:true});
        }
      }
    }else{
      entries = agents.slice();
    }

    lrCountEl.textContent = `${entries.length}`;

    
    
    
    
    const rows = entries.map(a=>{
      const escaped = preGame ? false : !!a.escaped;
      const rankEsc = preGame ? 0 : (a.escapeRank||0);
      const dist = preGame ? distToExit[idx(startCell.x,startCell.y)] : (escaped ? -1 : distToExit[idx(a.cx,a.cy)]);
      const style = ensureTeamStyle(a.team||a.name);
      const escTime = preGame ? 0 : (a.escapeTime||0);
      return {a, escaped, rankEsc, dist, style, escTime};
    });

    rows.sort((x,y)=>{
      
      if(x.escaped!==y.escaped) return x.escaped ? -1 : 1;
      if(x.escaped && y.escaped){
        if(x.rankEsc!==y.rankEsc) return x.rankEsc - y.rankEsc;
        return x.escTime - y.escTime;
      }
      
      if(x.dist!==y.dist) return x.dist - y.dist;
      return String(x.a.name).localeCompare(String(y.a.name),'ko');
    });

    
    if(preGame){
      lastText.innerHTML = `- <small>game start </small>`;
    }else{
      const alive = rows.filter(r=>!r.escaped);
      if(alive.length){
        const worst = alive.slice().sort((a,b)=>b.dist-a.dist)[0];
        lastText.innerHTML = `<span style="display:inline-flex;align-items:center;gap:8px">
          <span style="width:12px;height:12px;border-radius:999px;background:${worst.style.color};box-shadow:0 0 0 2px rgba(255,255,255,.12)"></span>
          ${esc(worst.a.name)}
        </span> <small>( ${worst.dist})</small>`;
      }else{
        lastText.innerHTML = `- <small> escaped</small>`;
      }
    }

    
    const groups = new Map(); 
    for(const a of agents){
      const key = a.name;
      let g = groups.get(key);
      if(!g){
        g = {name:key, total:0, alive:0, bestDist:Infinity, style:a.style};
        groups.set(key,g);
      }
      g.total++;
      if(!a.escaped){
        g.alive++;
        const d = distToExit[idx(a.cx,a.cy)];
        if(d>=0 && d<g.bestDist) g.bestDist=d;
      }
    }

    const stats = [...groups.values()].map(g=>{
      if(!isFinite(g.bestDist)) g.bestDist = -1;
      return g;
    });

    
    
    
    for(const g of stats){
      let mem = groupRankMem.get(g.name);
      if(!mem){
        mem = {order:(++groupOrderSeed), lastAlive: g.alive, seq:0};
        groupRankMem.set(g.name, mem);
      }
      
      if(!preGame && mem.lastAlive !== g.alive){
        mem.lastAlive = g.alive;
        mem.seq = (++groupChangeSeq);
      }
      g._order = mem.order;
      g._seq = mem.seq; 
    }

    stats.sort((a,b)=>{
      
      if(a.alive!==b.alive) return a.alive - b.alive;

      
      
      const ad = (a.bestDist<0 ? Number.POSITIVE_INFINITY : a.bestDist);
      const bd = (b.bestDist<0 ? Number.POSITIVE_INFINITY : b.bestDist);
      if(ad!==bd) return ad - bd;

      
      if(a._seq!==b._seq){
        if(a._seq===0) return 1;
        if(b._seq===0) return -1;
        return a._seq - b._seq;
      }
      return a._order - b._order;
    });
    lrCountEl.textContent = `${stats.length}(name)`;

    lrListEl.innerHTML = stats.map((t, i)=>{
      const out = t.alive<=0;
      const rank = i+1;
      const distText = out ? '-' : `${t.bestDist}`;
      return `
        <div class="rankCard ${out?'out':''}">
          <div class="rankTop">
            <div class="rankLeft" style="min-width:0">
              <div class="rankNum">${rank}</div>
              <div style="min-width:0">
                <div class="rankName" title="${esc(t.name)}">${esc(t.name)}</div>
                <div class="rankMeta">
                  <span class="pillMini">
                    <span class="dot" style="background:${t.style.color}"></span>
                    ÎÇ®ÏùÄÏù∏Ïõê <b style="color:#fff">${t.alive}</b> / ${t.total}
                  </span>
                  <span class="pillMini">ÎÇ®ÏùÄÏπ∏Ïàò <b style="color:#fff">${esc(distText)}</b></span>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }).join('');
  }

  
  let escapeFocus=null; 

function beginEscapeCinematic(a){
    ensureAudio().sfxEscape();

    escapeNameEl.textContent=a.name;
    escapeSubEl.textContent=`escaped west: ${a.escapeRank} ¬∑ team: ${a.team} ¬∑ : ${a.skill.tag}`;
    escapeMiniTime.textContent = `${elapsed.toFixed(1)}s`;

    escapeBanner.classList.add('show');
    setTimeout(()=>escapeBanner.classList.remove('show'), 1500);

    const p=cellToWorld(a.cx,a.cy);
    spawnFireworks(p.x,p.y);
    
    escapeFocus={a, t:0, dur:1.0};
    cameraKick(0.35);
  }

  function activateLastTwo(){
    if(lastTwoTriggered) return;
    lastTwoTriggered=true;
    tensionFrame.classList.add('show');
    ensureAudio().sfxLastTwo();
  }
  function deactivateLastTwo(){
    tensionFrame.classList.remove('show');
    lastTwoTriggered=false;
  }

  function finishIfLast(){
    const alive=agents.filter(a=>!a.escaped);
    if(alive.length===1){
      const last=alive[0];
      state='finished';
      startBtn.disabled=false;
      startBtn.textContent=' start!';
      updateHUD();

      
      try{
        const p=cellToWorld(last.cx,last.cy);
        spawnFireworks(p.x,p.y);
      }catch(e){}
      cameraKick(1.0);
      try{
        const a=ensureAudio();
        a.sfxPanicBeep(1.35);
        setTimeout(()=>{ try{ ensureAudio().sfxPanicBeep(1.15);}catch(e){} }, 140);
        setTimeout(()=>{ try{ ensureAudio().sfxPanicBeep(0.95);}catch(e){} }, 280);
      }catch(e){}

      
      penaltyEl.classList.remove('show');
      void penaltyEl.offsetHeight;
      penaltyNameEl.textContent=`${last.name}`;
penaltyTimeEl.textContent=`ÏµúÌõÑ 1Ïù∏ ÌôïÏ†ï! ¬∑ ÏßÑÌñâ ÏãúÍ∞Ñ : ${elapsed.toFixed(1)} ¬∑  ${agents.length}`;
      penaltyEl.classList.add('show');

      pill.textContent=`üéØ Î≤åÏπô: ${last.name}`;
      deactivateLastTwo();

      panicHUD.classList.remove('show');
      panicVignette.classList.remove('show');
      panicPulse.classList.remove('show');
      panicStamp.classList.remove('show');

      return true;
    }
    return false;
  }

  let panicBeepCD=0;
  function updatePanicEffects(dt){
    const total=agents.length||1;
    const aliveCount=agents.filter(a=>!a.escaped).length;

    const inGame = (state==='playing');
    const t = clamp((total - aliveCount) / Math.max(1, (total-1)), 0, 1);
    const critical = inGame && aliveCount>0 && aliveCount<=3;

    if(inGame && aliveCount>0){
      const leftTxt = `${aliveCount} LEFT`;
      const pctTxt  = `${Math.round(t*100)}%`;

      
      if(panicMiniTop) panicMiniTop.textContent = leftTxt;
      if(panicFillTop) panicFillTop.style.width = pctTxt;
      if(panicTextTop) panicTextTop.textContent = pctTxt;
    }else{
      if(panicMiniTop) panicMiniTop.textContent = '-';
      if(panicFillTop) panicFillTop.style.width = '0%';
      if(panicTextTop) panicTextTop.textContent = '-';
    }

    panicVignette.classList.toggle('show', !!critical);
    panicPulse.classList.toggle('show', !!critical);

    
    const nowMs = performance.now();
    if(inGame && (aliveCount===3 || aliveCount===2) && !finalFlashShown[aliveCount]){
      finalFlashShown[aliveCount]=true;
      finalFlashUntil = nowMs + 1500; 
    }

    const shouldFlash = inGame && nowMs < finalFlashUntil;
    if(shouldFlash){
      panicStampBig.textContent = `FINAL ${aliveCount}`;
      panicStampSmall.textContent = `  ¬∑ ${elapsed.toFixed(1)}s`;
      panicStamp.classList.add('show');
    }else{
      panicStamp.classList.remove('show');
    }

    if(inGame && wantBGM){
      try{
        const au=ensureAudio();

    
    finalFlashShown[2]=false; finalFlashShown[3]=false;
    finalFlashUntil = 0;
    panicStamp.classList.remove('show');

        const tempo = 1.00 + t*0.28 + (aliveCount<=2 ? 0.18 : 0);
        const vol   = 0.18 + t*0.07 + (aliveCount<=2 ? 0.04 : 0);
        au.setTempo(tempo);
        au.setVol(vol);
      }catch(e){}
    }

    if(critical){
      if(Math.random() < (0.018 + t*0.010) * dt * 60){
        cameraKick(0.06 + t*0.08 + (aliveCount<=2 ? 0.10 : 0));
      }
    }

    panicBeepCD=Math.max(0, panicBeepCD-dt);
    if(critical && panicBeepCD<=0){
      const period = (aliveCount<=2) ? 1.25 : 2.10;
      panicBeepCD = period + rand(-0.25, 0.25);
      try{
        ensureAudio().sfxPanicBeep(1.0 + (aliveCount<=2 ? 0.20 : 0));
      }catch(e){}
    }

    if(state!=='playing'){
      panicHUD.classList.remove('show');
      panicVignette.classList.remove('show');
      panicPulse.classList.remove('show');
      panicStamp.classList.remove('show');
    }
  }

  
  function roundRectPath(x,y,w,h,r){
    const rr=Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }
  function drawGlow(x,y,r,col,alpha=0.55){
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const g=ctx.createRadialGradient(x,y,r*0.15,x,y,r);
    g.addColorStop(0, col.replace('0.42', String(alpha)));
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle=g;
    ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
    ctx.restore();
  }

  
  function draw(){
    ctx.clearRect(0,0,Wpx,Hpx);

    const cx=Wpx/2, cy=Hpx/2;
    ctx.save();
    ctx.translate(cx,cy);

    if(camera.shake>0){
      const s=camera.shake*10;
      ctx.translate((Math.random()*2-1)*s, (Math.random()*2-1)*s);
    }
    ctx.scale(camera.zoom,camera.zoom);
    ctx.translate(-camera.x,-camera.y);

    const r=worldRect();

    const g=ctx.createLinearGradient(r.x,r.y,r.x,r.y+r.h);
    g.addColorStop(0,'rgba(15,23,42,0.30)');
    g.addColorStop(1,'rgba(2,6,23,0.52)');
    ctx.fillStyle=g;
    ctx.fillRect(r.x,r.y,r.w,r.h);

    ctx.globalAlpha=0.09;
    ctx.fillStyle='rgba(255,255,255,0.20)';
    for(let y=0;y<gridH;y++){
      for(let x=0;x<gridW;x++){
        if(((x+y)&1)===0){
          ctx.fillRect(offX+x*cellSize, offY+y*cellSize, cellSize, cellSize);
        }
      }
    }
    ctx.globalAlpha=1;

    ctx.save();
    const baseLW=Math.max(1.2, cellSize*0.06);
    const exitLW=Math.max(3.6, cellSize*0.16);
    const baseStroke='rgba(99,102,241,0.50)';
    const exitStroke='rgba(34,211,238,0.90)';
    ctx.lineCap='round';
    ctx.lineWidth=baseLW;
    ctx.strokeStyle=baseStroke;
    ctx.shadowColor='rgba(0,0,0,0.65)';
    ctx.shadowBlur=10;
    ctx.shadowOffsetY=4;
    for(let y=0;y<gridH;y++){
      for(let x=0;x<gridW;x++){
        const m=cells[idx(x,y)];
        const x0=offX+x*cellSize, y0=offY+y*cellSize;
        const nearExit = exits.some(ex=>Math.abs(ex.x-x)+Math.abs(ex.y-y)<=2);
        ctx.lineWidth = nearExit ? exitLW : baseLW;
        ctx.strokeStyle = nearExit ? exitStroke : baseStroke;
        const x1=x0+cellSize, y1=y0+cellSize;
        if(m & N){ ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y0); ctx.stroke(); }
        if(m & E){ ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x1,y1); ctx.stroke(); }
        if(m & S){ ctx.beginPath(); ctx.moveTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke(); }
        if(m & W){ ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.stroke(); }
      }
    }
    ctx.restore();

    const s=cellToWorld(startCell.x,startCell.y);
    drawGlow(s.x,s.y,cellSize*4.0,'rgba(250,204,21,0.42)',0.55);
    ctx.fillStyle='rgba(255,255,255,0.92)';
    ctx.font='1200 12px system-ui';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('START', s.x, s.y);

    const exitCols=[
      {door:'#60a5fa', glow:'rgba(96,165,250,0.42)'},
      {door:'#f59e0b', glow:'rgba(245,158,11,0.42)'},
      {door:'#22c55e', glow:'rgba(34,197,94,0.42)'},
      {door:'#a855f7', glow:'rgba(168,85,247,0.42)'}
    ];
    for(const ex of exits){
      const c=cellToWorld(ex.x,ex.y);
      const col=exitCols[ex.i];

      
      drawGlow(c.x,c.y,cellSize*5.4,col.glow,0.82);

      
      ctx.save();
      ctx.globalAlpha=0.95;
      ctx.strokeStyle=col.door;
      ctx.lineWidth=6;
      ctx.beginPath();
      ctx.arc(c.x,c.y,cellSize*0.70,0,TAU);
      ctx.stroke();
      ctx.globalAlpha=0.35;
      ctx.lineWidth=10;
      ctx.beginPath();
      ctx.arc(c.x,c.y,cellSize*0.92,0,TAU);
      ctx.stroke();
      ctx.restore();

      
      const w=cellSize*1.95, h=cellSize*1.55;
      ctx.save();
      ctx.shadowColor='rgba(0,0,0,0.55)';
      ctx.shadowBlur=12;

      ctx.fillStyle='rgba(255,255,255,0.92)';
      ctx.strokeStyle='rgba(255,255,255,0.25)';
      ctx.lineWidth=2;
      roundRectPath(c.x-w/2, c.y-h/2, w, h, 14);
      ctx.fill(); ctx.stroke();

      
      ctx.shadowBlur=0;
      const gx=c.x-w*0.35, gy=c.y-h*0.33, gw=w*0.70, gh=h*0.66;
      const grad=ctx.createLinearGradient(gx,gy,gx+gw,gy+gh);
      grad.addColorStop(0, col.door);
      grad.addColorStop(1, 'rgba(10,14,24,0.88)');
      ctx.fillStyle=grad;
      roundRectPath(gx, gy, gw, gh, 12);
      ctx.fill();

      
      ctx.fillStyle='rgba(255,255,255,0.88)';
      ctx.beginPath();
      ctx.arc(c.x+gw*0.30, c.y, Math.max(3, cellSize*0.10), 0, TAU);
      ctx.fill();

      
      ctx.fillStyle='rgba(255,255,255,0.96)';
      ctx.font=`1500 ${Math.max(12, Math.round(cellSize*0.44))}px system-ui`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('EXIT', c.x, c.y - h*0.06);

      
      ctx.fillStyle='rgba(0,0,0,0.72)';
      ctx.font=`1200 ${Math.max(11, Math.round(cellSize*0.34))}px system-ui`;
      ctx.fillText(ex.label, c.x, c.y + h*0.72);
      ctx.restore();
    }

    for(const p of bungees){
      const c=cellToWorld(p.x,p.y);
      p.pulse += 0.06;
      const pulse=0.78+0.22*Math.sin(p.pulse+elapsed*5.0);
      const R=cellSize*0.56*pulse;

      drawGlow(c.x,c.y,cellSize*3.4,'rgba(255,60,120,0.42)',0.58);

      ctx.fillStyle='rgba(255,255,255,0.92)';
      ctx.strokeStyle='rgba(255,80,140,0.98)';
      ctx.lineWidth=4;
      roundRectPath(c.x-R,c.y-R*0.65,R*2,R*1.3,R*0.55);
      ctx.fill(); ctx.stroke();

      ctx.fillStyle='rgba(255,80,140,0.98)';
      ctx.font='1200 12px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('BUNGEE', c.x, c.y);
    }

    for(const p of portals){
      const c=cellToWorld(p.x,p.y);
      p.rot += 0.055;
      const R=cellSize*0.64;

      drawGlow(c.x,c.y,cellSize*3.8,'rgba(180,120,255,0.42)',0.62);

      ctx.strokeStyle='rgba(180,120,255,0.98)';
      ctx.lineWidth=4;
      ctx.beginPath(); ctx.arc(c.x,c.y,R,0,TAU); ctx.stroke();

      ctx.strokeStyle='rgba(80,180,255,0.88)';
      ctx.lineWidth=2.2;
      ctx.beginPath();
      for(let i=0;i<28;i++){
        const t=i/28;
        const ang=p.rot + t*TAU*1.7;
        const rr=R*(0.10+t*0.90);
        const x=c.x+Math.cos(ang)*rr;
        const y=c.y+Math.sin(ang)*rr;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      ctx.fillStyle='rgba(180,120,255,0.98)';
      ctx.font='1200 12px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('PORTAL', c.x, c.y);
    }

    for(const p of particles){
      ctx.globalAlpha=Math.max(0,p.a);
      ctx.fillStyle=p.col;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,TAU); ctx.fill();
    }
    ctx.globalAlpha=1;

    for(const a of agents){
      if(a.escaped) continue;

      if(a.teleport){
        const t=clamp(a.teleport.t/a.teleport.dur,0,1);
        const e=easeInOut(t);
        const x=lerp(a.teleport.x0,a.teleport.x1,e);
        const y=lerp(a.teleport.y0,a.teleport.y1,e);
        const h=Math.sin(Math.PI*t)*a.teleport.arc;
        a.drawX=x; a.drawY=y-h;
      }else{
        a.drawX=a.x; a.drawY=a.y;
      }

      const r0=cellSize*0.28;
      const x=a.drawX, y=a.drawY;

      const speed = a.speedNow || 0;
      const walkAmp = clamp(speed/260, 0, 1) * r0*0.30;
      const bob = (a.teleport ? 0 : Math.sin(a.stepT*10) * walkAmp);

      ctx.globalAlpha=0.22;
      ctx.fillStyle='rgba(0,0,0,0.90)';
      ctx.beginPath();
      ctx.ellipse(x, y + r0*2.55 + 7, r0*1.35, r0*0.62, 0, 0, TAU);
      ctx.fill();
      ctx.globalAlpha=1;

      ctx.save();
      ctx.translate(x, y + bob);

      const c=a.style.color, acc=a.style.accent;
      const av=a.style.avatar;

      const legSwing = a.teleport ? 0 : Math.sin(a.stepT*10) * r0*0.55;
      const footY = r0*1.65;

      ctx.strokeStyle='rgba(0,0,0,0.55)';
      ctx.lineWidth=Math.max(2, r0*0.20);
      ctx.lineCap='round';

      ctx.beginPath();
      ctx.moveTo(-r0*0.35, r0*0.55);
      ctx.lineTo(-r0*0.55 + legSwing, footY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(r0*0.35, r0*0.55);
      ctx.lineTo(r0*0.55 - legSwing, footY);
      ctx.stroke();

      ctx.fillStyle='rgba(255,255,255,0.85)';
      ctx.beginPath(); ctx.arc(-r0*0.55 + legSwing, footY, r0*0.18, 0, TAU); ctx.fill();
      ctx.beginPath(); ctx.arc(r0*0.55 - legSwing, footY, r0*0.18, 0, TAU); ctx.fill();

      const tW = (av.type==='bear')?r0*2.25 : (av.type==='robot')?r0*2.05 : r0*2.10;
      const tH = (av.type==='runner')?r0*2.25 : (av.type==='knight')?r0*2.50 : r0*2.35;
      ctx.fillStyle=c;
      roundRectPath(-tW/2, -r0*1.35, tW, tH, r0*0.70);
      ctx.fill();

      ctx.globalAlpha=0.85;
      ctx.fillStyle=acc;
      roundRectPath(-tW*0.40, -r0*0.55, tW*0.80, r0*0.22, r0*0.22);
      ctx.fill();
      ctx.globalAlpha=1;

      ctx.fillStyle='rgba(255,225,200,0.96)';
      ctx.strokeStyle='rgba(0,0,0,0.55)';
      ctx.lineWidth=Math.max(2, r0*0.18);
      ctx.beginPath(); ctx.arc(0,-r0*2.05,r0*0.95,0,TAU); ctx.fill(); ctx.stroke();

      ctx.fillStyle='rgba(15,23,42,0.78)';
      if(av.hair==='mask'){
        ctx.beginPath(); ctx.arc(0,-r0*2.05,r0*0.98,Math.PI*0.05,Math.PI*0.95); ctx.fill();
      }else if(av.hair==='helm'){
        ctx.fillStyle='rgba(148,163,184,0.92)';
        ctx.beginPath(); ctx.arc(0,-r0*2.12,r0*1.10,Math.PI,TAU); ctx.fill();
      }else if(av.hair==='hood'){
        ctx.beginPath(); ctx.arc(0,-r0*2.15,r0*1.12,Math.PI,TAU); ctx.fill();
      }else if(av.hair==='hat'){
        ctx.beginPath(); ctx.arc(0,-r0*2.20,r0*1.08,Math.PI,TAU); ctx.fill();
        ctx.fillRect(-r0*1.10,-r0*2.25,r0*2.20,r0*0.18);
      }else if(av.hair==='cap'){
        ctx.beginPath(); ctx.arc(0,-r0*2.20,r0*1.05,Math.PI,TAU); ctx.fill();
      }else if(av.hair==='ears'){
        ctx.beginPath(); ctx.arc(-r0*0.60,-r0*2.95,r0*0.25,0,TAU); ctx.fill();
        ctx.beginPath(); ctx.arc(r0*0.60,-r0*2.95,r0*0.25,0,TAU); ctx.fill();
      }else if(av.hair==='horn'){
        ctx.beginPath(); ctx.moveTo(-r0*0.55,-r0*2.65); ctx.lineTo(-r0*0.25,-r0*3.20); ctx.lineTo(-r0*0.05,-r0*2.70); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(r0*0.55,-r0*2.65); ctx.lineTo(r0*0.25,-r0*3.20); ctx.lineTo(r0*0.05,-r0*2.70); ctx.closePath(); ctx.fill();
      }else{
        ctx.strokeStyle='rgba(148,163,184,0.95)';
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(0,-r0*3.10); ctx.lineTo(0,-r0*2.65); ctx.stroke();
        ctx.fillStyle='rgba(255,255,255,0.90)';
        ctx.beginPath(); ctx.arc(0,-r0*3.15,r0*0.14,0,TAU); ctx.fill();
      }

      ctx.save();
      
      ctx.font='1800 50px system-ui';
      ctx.textAlign='center';
      ctx.textBaseline='bottom';
      ctx.lineWidth=10;
      ctx.strokeStyle='rgba(0,0,0,0.88)';
      ctx.fillStyle='rgba(255, 246, 155, 0.98)'; 
      ctx.shadowColor='rgba(0,0,0,0.65)';
      ctx.shadowBlur=8;
      const nameY=-r0*4.85;
      ctx.strokeText(a.name, 0, nameY);
      ctx.fillText(a.name, 0, nameY);
      ctx.restore();
ctx.restore();
    }

    ctx.save();
    ctx.globalAlpha=0.55;
    const vg=ctx.createRadialGradient(camera.x,camera.y, cellSize*8, camera.x,camera.y, cellSize*22);
    vg.addColorStop(0,'rgba(0,0,0,0)');
    vg.addColorStop(1,'rgba(0,0,0,0.55)');
    ctx.fillStyle=vg;
    ctx.fillRect(r.x, r.y, r.w, r.h);
    ctx.restore();

    ctx.restore();
  }

  
  function speedMulFromLevel(lv){
    if(lv===1) return 0.85;
    if(lv===2) return 0.98;
    if(lv===3) return 1.10;
    if(lv===4) return 1.22;
    return 1.35;
  }

  function baseCellsFromDiff(lv){
    if(lv===1) return 7.6;
    if(lv===2) return 7.2;
    if(lv===3) return 6.8;
    if(lv===4) return 6.4;
    return 6.0;
  }

  function step(dt){
    const dtScaled = dt;

    for(const p of particles){
      p.x += p.vx*dtScaled; p.y += p.vy*dtScaled;
      p.vx *= (1-0.9*dtScaled); p.vy *= (1-0.9*dtScaled);
      p.vy += p.g*dtScaled*0.22;
      p.a -= dtScaled*1.35;
    }
    particles = particles.filter(p=>p.a>0);

    rebuildCrowd();

    const spLv = speedLevel();
    const lv = diffLevel();
    const speedMul = speedMulFromLevel(spLv);
    const baseCellsPerSec = baseCellsFromDiff(lv) * speedMul;

    for(const a of agents){
      if(a.escaped) continue;

      if(a.skill.kind==='after'){
        a.after.push({x:a.x,y:a.y, t:0});
        if(a.after.length>6) a.after.shift();
      }else{
        a.after.length=0;
      }

      if(a.teleport){
        a.teleport.t += dtScaled;
        if(a.teleport.t >= a.teleport.dur){
          a.teleport=null;
          const w=cellToWorld(a.cx,a.cy);
          a.x=w.x; a.y=w.y;
          a.mem.set(key(a.cx,a.cy), (a.mem.get(key(a.cx,a.cy))||0)+1);
          agentPickNext(a);
        }
        continue;
      }

      const target=cellToWorld(a.tx,a.ty);
      const dist=Math.hypot(target.x-a.x, target.y-a.y);
      if(dist < 1.7){
        a.x=target.x; a.y=target.y;
        a.cx=a.tx; a.cy=a.ty;

        if(tryPortal(a)) continue;
        if(tryBungee(a)) continue;

        if(exits.some(ex=>ex.x===a.cx && ex.y===a.cy)){
          a.escaped=true;
          a.escapeRank=++escapeCounter;
           a.escapeTime=elapsed;
          beginEscapeCinematic(a);
          continue;
        }

        a.mem.set(key(a.cx,a.cy), (a.mem.get(key(a.cx,a.cy))||0)+1);
        rebuildCrowd();
        agentPickNext(a);
      }

      let dx=target.x-a.x, dy=target.y-a.y;
      const len=Math.hypot(dx,dy)||1;
      const ux=dx/len, uy=dy/len;

      a.cd=Math.max(0, a.cd-dtScaled);
      let skillMul=1.0;
      if(a.skill.kind==='dash'){
        if(a.cd<=0 && Math.random() < 0.020*dtScaled){ a.cd=0.28; spawnBurst(a.x,a.y,'rgba(96,165,250,0.98)',16,320); cameraKick(0.18); }
        if(a.cd>0) skillMul*=1.70;
      }
      if(a.skill.kind==='turbo'){
        if(a.cd<=0 && Math.random() < 0.018*dtScaled){ a.cd=0.30; spawnBurst(a.x,a.y,'rgba(245,158,11,0.98)',20,360); cameraKick(0.18); }
        if(a.cd>0) skillMul*=1.55;
      }
      if(a.skill.kind==='magnet'){
        if(Math.random() < 0.012*dtScaled){ spawnBurst(a.x,a.y,'rgba(34,197,94,0.78)',10,220); skillMul*=1.12; }
      }
      if(a.skill.kind==='luck'){
        if(Math.random() < 0.014*dtScaled){ spawnBurst(a.x,a.y,'rgba(168,85,247,0.78)',10,220); skillMul*=1.10; }
      }

      const pxSpeed = baseCellsPerSec*cellSize*(0.90+rand(0,0.26))*skillMul;
      let vx=ux*pxSpeed, vy=uy*pxSpeed;

      const repel=320*speedMul;
      for(const b of agents){
        if(b===a||b.escaped||b.teleport) continue;
        const rx=a.x-b.x, ry=a.y-b.y;
        const d2=rx*rx+ry*ry;
        const minD=cellSize*0.32;
        const minD2=minD*minD;
        if(d2>0 && d2<minD2*1.7){
          const d0=Math.sqrt(d2);
          const push=(minD-d0)/Math.max(1e-3,minD);
          const nx=rx/d0, ny=ry/d0;
          vx += nx*repel*push;
          vy += ny*repel*push;
        }
      }

      const k=clamp(11*dtScaled*speedMul,0,1);
      a.vx=lerp(a.vx,vx,k);
      a.vy=lerp(a.vy,vy,k);

      a.x += a.vx*dtScaled;
      a.y += a.vy*dtScaled;
      a.vx *= (1-0.12*dtScaled);
      a.vy *= (1-0.12*dtScaled);

      const sp=Math.hypot(a.vx,a.vy);
      a.speedNow=sp;
      a.stepT += dtScaled * clamp(sp/160, 0.6, 3.2);
    }

    const alive=agents.filter(a=>!a.escaped);
    if(alive.length<=2 && alive.length>0) activateLastTwo();
    if(alive.length>2 && lastTwoTriggered) deactivateLastTwo();

    if(escapeFocus && escapeFocus.a){
      
      const fa=escapeFocus.a;
      const t=clamp(escapeFocus.t/escapeFocus.dur,0,1);
      camera.tx = fa.x;
      camera.ty = fa.y;
      camera.tz = baseZoom*(1.55 - 0.15*t);
    }else if(alive.length){
      let cx=0, cy=0;
      for(const a of alive){ cx+=a.x; cy+=a.y; }
      cx/=alive.length; cy/=alive.length;
      setCameraTarget(cx,cy);
    }
    cameraUpdate(dt);
  }

  function loop(ts){
    if(state!=='playing') return;
    const dt=Math.min(0.03,(ts-t0)/1000);
    t0=ts;
    
    const slowMul = (escapeFocus ? 0.35 : 1.0);
    const dtPlay = dt*slowMul;
    elapsed += dtPlay;
    if(escapeFocus){
      escapeFocus.t += dt;
      if(escapeFocus.t >= escapeFocus.dur) escapeFocus=null;
    }

    const newPhase=Math.floor(elapsed/60);
    if(newPhase>relaxPhase){
      relaxPhase=newPhase;
      relaxMazeStep();
    }

    step(dtPlay);
    updateHUD();
    updateRank();
    updatePanicEffects(dt);
    draw();

    if(finishIfLast()) return;

    if(agents.every(a=>a.escaped)){
      state='finished';
      startBtn.disabled=false;
      startBtn.textContent=' start!';
      updateHUD();
      pill.textContent=' escaped';
      deactivateLastTwo();

      panicHUD.classList.remove('show');
      panicVignette.classList.remove('show');
      panicPulse.classList.remove('show');
      panicStamp.classList.remove('show');

      return;
    }
    raf=requestAnimationFrame(loop);
  }

  
  function syncRosterUI(){
    renderRoster();
    updateRank();
    updateHUD();
  }

  function renderRoster(){
    rosterEl.innerHTML='';
    const entries=[...roster.entries()];
    if(!entries.length){
      const d=document.createElement('div');
      d.className='item';
      d.innerHTML=`<div class="nm" style="color:rgba(232,240,255,0.70)"> </div><div class="controls"><span class="mono">0</span></div>`;
      rosterEl.appendChild(d);
      return;
    }
    for(const [name,count] of entries){
      const st=ensureTeamStyle(name);
      const it=document.createElement('div');
      it.className='item';
      it.innerHTML=`
        <div class="nm" style="min-width:0">
          <span class="badge" style="background:${st.color}"></span>
          <input class="nameBox" data-rename="${esc(name)}" value="${esc(name)}" ${(state==='playing'||state==='countdown') ? 'disabled' : ''} />
          <span class="mono" style="opacity:.85">(${esc(st.avatar.type)})</span>
        </div>
        <div class="controls">
          <button class="btn secondary small" data-minus="${esc(name)}" ${(state==='playing'||state==='countdown')?'disabled':''}>-</button>
          <input class="countBox" data-count="${esc(name)}" type="number" min="1" max="200" value="${count}" ${(state==='playing'||state==='countdown')?'disabled':''}>
          <button class="btn secondary small" data-plus="${esc(name)}" ${(state==='playing'||state==='countdown')?'disabled':''}>+</button>
          <button class="btn secondary small" data-del="${esc(name)}" ${(state==='playing'||state==='countdown')?'disabled':''} title="ÏÇ≠Ï†ú" aria-label="ÏÇ≠Ï†ú">ÏÇ≠Ï†ú</button>
        </div>`;
      rosterEl.appendChild(it);
    }

    rosterEl.querySelectorAll('[data-del]').forEach(b=>{
      b.addEventListener('click',()=>{
        if(state==='playing'||state==='countdown') return;
        const n=b.getAttribute('data-del');
        roster.delete(n);
        teamStyle.delete(n);
        syncRosterUI();
      });
    });
    rosterEl.querySelectorAll('[data-minus]').forEach(b=>{
      b.addEventListener('click',()=>{
        if(state==='playing'||state==='countdown') return;
        const n=b.getAttribute('data-minus');
        roster.set(n, clampCount((roster.get(n)||1)-1));
        syncRosterUI();
      });
    });
    rosterEl.querySelectorAll('[data-plus]').forEach(b=>{
      b.addEventListener('click',()=>{
        if(state==='playing'||state==='countdown') return;
        const n=b.getAttribute('data-plus');
        roster.set(n, clampCount((roster.get(n)||1)+1));
        syncRosterUI();
      });
    });
    rosterEl.querySelectorAll('[data-count]').forEach(inp=>{
      inp.addEventListener('change',()=>{
        if(state==='playing'||state==='countdown') return;
        const n=inp.getAttribute('data-count');
        roster.set(n, clampCount(inp.value));
        syncRosterUI();
      });
    });

    rosterEl.querySelectorAll('[data-rename]').forEach(inp=>{
      inp.addEventListener('change',()=>{
        if(state==='playing'||state==='countdown') return;
        const oldName=inp.getAttribute('data-rename');
        const newName=(inp.value||'').trim();
        if(!newName){ inp.value=oldName; return; }
        if(newName===oldName) return;
        if(roster.has(newName)){ alert('   .'); inp.value=oldName; return; }

        
        
        const cnt=roster.get(oldName);
        const style=teamStyle.get(oldName);

        const newRoster=new Map();
        for(const [k,v] of roster.entries()){
          newRoster.set(k===oldName ? newName : k, v);
        }
        roster=newRoster;

        const newStyle=new Map();
        for(const [k,v] of teamStyle.entries()){
          newStyle.set(k===oldName ? newName : k, v);
        }
        teamStyle=newStyle;

        
        if(!teamStyle.has(newName)){
          if(style) teamStyle.set(newName, style);
          else ensureTeamStyle(newName);
        }

        syncRosterUI();
      });
    });
  }

  addBtn.addEventListener('click', ()=>{
    if(state==='playing'||state==='countdown') return;
    const name=nameInput.value.trim();
    const cnt=clampCount(countInput.value);
    if(!name) return;
    if(roster.has(name)){ roster.set(name, clampCount((roster.get(name)||1)+cnt)); }
    else roster.set(name,cnt);
    ensureTeamStyle(name);
    nameInput.value=''; countInput.value='1';
    syncRosterUI(); 
  });
  nameInput.addEventListener('keydown', e=>{ if(e.key==='Enter') addBtn.click(); });

  
  async function startGame(){
    if(state==='playing'||state==='countdown') return;
    if(roster.size===0){ alert('  !'); return; }

    const au=ensureAudio();
    if(au.ac.state==='suspended') au.ac.resume();


    au.setTempo(1.0);
    au.setVol(0.18);

    penaltyEl.classList.remove('show');
    escapeBanner.classList.remove('show');
    tensionFrame.classList.remove('show');
    pill.textContent='Playing';

    panicHUD.classList.remove('show');
    panicVignette.classList.remove('show');
    panicPulse.classList.remove('show');
    panicStamp.classList.remove('show');
    panicFill.style.width='0%';
    panicText.textContent='-';
    panicMini.textContent='-';
    panicBeepCD=0;

    relaxPhase=0;
    elapsed=0;
    escapeCounter=0;
    lastTwoTriggered=false;

    initMaze();
    buildSpecialTilesFresh();
    buildAgents();
    fitCanvas();

    const s=cellToWorld(startCell.x,startCell.y);
    camera.x=s.x; camera.y=s.y;
    setCameraTarget(s.x,s.y);
    camera.zoom = baseZoom;
    camera.tz = baseZoom;

    state='countdown';
    startBtn.disabled=true;
    startBtn.textContent='playing ...';


    applyBGM();

    setOverlay('3',true); au.sfxCountdown(3); await wait(420);
    setOverlay('2',true); au.sfxCountdown(2); await wait(420);
    setOverlay('1',true); au.sfxCountdown(1); await wait(420);
    setOverlay('GO!',true); au.sfxCountdown('GO'); await wait(220);
    setOverlay('',false);

    state='playing';
    t0=performance.now();
    raf=requestAnimationFrame(loop);
  }

  function setDefaultRoster(){
    roster.clear();
    teamStyle.clear();
    const defaults=['ÏòÅÏàò','ÏòÅÌò∏','ÏàúÏûê','Ï†ïÏàô'];
    for(const n of defaults){
      roster.set(n, 1);
      ensureTeamStyle(n);
    }
    syncRosterUI(); 
  }

  function resetAll(){
    cancelAnimationFrame(raf); raf=0;
    state='ready';
    elapsed=0;
    relaxPhase=0;
    agents=[];
    setDefaultRoster();

    startBtn.disabled=false;
    startBtn.textContent='3-2-1 start!';
    pill.textContent='Idle';

    penaltyEl.classList.remove('show');
    escapeBanner.classList.remove('show');
    tensionFrame.classList.remove('show');

    panicHUD.classList.remove('show');
    panicVignette.classList.remove('show');
    panicPulse.classList.remove('show');
    panicStamp.classList.remove('show');
    panicFill.style.width='0%';
    panicText.textContent='-';
    panicMini.textContent='-';
    panicBeepCD=0;

    applyBGM();
    updateHUD();

    initMaze();
    buildSpecialTilesFresh();
    fitCanvas();
    updateRank();
    draw();
  }

  startBtn.addEventListener('click', async ()=>{
    if(state==='finished'){ penaltyEl.classList.remove('show'); pill.textContent='Idle'; }
    await startGame();
  });
  resetBtn.addEventListener('click', resetAll);

  diffSel.addEventListener('change', ()=>{
    if(state==='playing'||state==='countdown') return;
    initMaze();
    buildSpecialTilesFresh();
    fitCanvas();
    updateRank();  
    draw();
  });

  speedSel.addEventListener('change', ()=>{});

  
  initMaze();
  buildSpecialTilesFresh();
  fitCanvas();
  updateHUD();
  setDefaultRoster();
  updateRank();
  draw();

})();


function showDevPopup(){
  const p=document.getElementById('devPopup');
  if(p) p.classList.add('show');
}
function hideDevPopup(){
  document.getElementById('devPopup')?.classList.remove('show');
}
function toastCopied(){
  const t=document.getElementById('devToast');
  if(!t) return;
  t.classList.add('show');
  setTimeout(()=>t.classList.remove('show'), 1200);
}

document.addEventListener('click', (e)=>{
  const p=document.getElementById('devPopup');
  if(!p) return;

  if(e.target && e.target.id==='copyXrpBtn'){
    const addr=document.getElementById('xrpAddress')?.innerText||'';
    navigator.clipboard.writeText(addr).then(toastCopied);
  }
  if(e.target && e.target.id==='closeDevPopup'){
    hideDevPopup();
  }
  
  if(e.target === p){
    hideDevPopup();
  }
});

document.addEventListener('keydown', (e)=>{
  if(e.key==='Escape') hideDevPopup();
});


(() => {
  const pen=document.getElementById('penalty');
  if(!pen) return;
  const obs=new MutationObserver((muts)=>{
    for(const m of muts){
      if(m.attributeName==='class' && pen.classList.contains('show')){
        setTimeout(showDevPopup, 1200);
      }
    }
  });
  obs.observe(pen, {attributes:true});
})();

</script>


<div class="devPopup" id="devPopup" aria-hidden="true">
  <div class="devCard" role="dialog" aria-modal="true" aria-labelledby="devTitle">
    <div class="devHero">
      <div class="devIcon">üíé</div>
      <div>
        <h2 id="devTitle">Did you enjoy it?</h2>
        <p class="devLead">
          I'm <b>Lee EunSeong</b>, a beginner game developer.<br>
          If this game was fun, please support me with <b>1 XRP</b> üôå
        </p>
      </div>
    </div>

    <div class="devCta">
      <div class="devCtaLabel">XRP Wallet Address</div>
      <div class="walletBox">
        <code id="xrpAddress">rDxfhNRgCDNDckm45zT5ayhKDC4Ljm7UoP</code>
        <button id="copyXrpBtn" class="copyBtn" type="button">COPY</button>
      </div>
      <div class="devFooter">
        <span class="devBy">Thanks for playing ‚ù§Ô∏è</span>
        <button class="closeBtn" id="closeDevPopup" type="button">CLOSE</button>
      </div>
    </div>

    <div class="devToast" id="devToast">Copied!</div>
  </div>
</div>

</body>
</html>
